//***************************************************************************************************************************************************
//          Программа азимутального поворотного устройства на TFT_HX8357&ILI9486 v9.0
//                          г.Снежное ДНР D0ITC 17 октября 2019 года
//                             Описание работы кнопки энкодера:
// 1. После первой загрузки программы в контроллер необходимо включить питание устройства с нажатой кнопкой энкодера, записать значения в ячейки EEPROM по умолчанию.
// 2. Кнопка энкодера работает только если антенна остановлена!!!
// 3. Одинарным кликом входим в режим навигации по МЕНЮ. Если ничего не выбирать то поистечении времени автоматически возвращаемся в основную программу.
//    Находясь в режиме навигации:
//    а. одинарным кликом входим в режим предустановок, энкодером выбираем нужную позицию, одинарным кликом подтверждаем выбор и возвращаемся в основную программу.
//       Находясь в режиме предустановок на выбранной позиции двойным кликом входим в режим коррекции азимута этой позиции,
//       энкодером выбираем нужное значение азимута. Двойным кликом выходим из режима коррекции.
//       Если в режиме предустановок ничего не выбрано то выходим из режима предустановок без изменения предыдущего азимута.
//       Тройным кликом выходим из режима предустановок без сохранения если выбор был сделан ошибочно.
//    б. двойным кликом входим на первую("page 1) страницу меню, энкодером выбираем нужную позицию, а одинарным кликом её значение. Двойным кликом выходим из меню 1.
//    в. тройным кликом входим на вторую("page 2) страницу меню, энкодером выбираем нужную позицию, а одинарным кликом её значение. Тройным кликом выходим из меню 2.
//       Если антенна находится не на 0°, то прежде чем переключится новый шаг датчика(1°, 5°, 10°, 15° или 22,5°), на экран вместо надписи "Step selection"
//       выводится "Going to azimuth 0°" и антенна движется на 0°. Как только сработает концевой выключатель будет принято новое значение шага датчика.
// 4. Двойным кликом вызываем индикацию часов. Вернуться в основную программу можно одинарным кликом. Находясь в программе часов двойным кликом входим в режим установки.
//    Одинарным переключаем позиции для коррекции по кольцу, изменяем значение энкодером. Находясь в режиме установки часов тройным кликом изменяем направление переключения пунктов.
//    Двойным кликом возвращаемся в программу часов с сохранением.
//    Находясь в программе часов тройным кликом входим в режим установки будильника. Одинарным переключаем между часами, минутами и секундами, выставляем энкодером.
//    Тройным изменяем направление переключения пунктов. После установки будильника автоматически возвращаемся в программу часов с сохранением.
// 5. Тройным кликом переходим на страницу чтения из памяти где можем при необходимости просмотреть содержимое используемых ячеек. Одинарным возвращаемся в основную программу.
//    Находясь на странице чтения из памяти двойным кликом входим в режим выбора рингтона. Двойным кликом изменяем рингтон и сразу прослушиваем его. Одинарным возвращаемся
//    на страницу чтения из памяти. Тройным кликом можем разрешить или запретить вывод часов в основной программе.
// 6. Если в основной программе около минуты ничего не происходит(не задаём новое направление, антенна не движется, не пользуемся меню) то входим в режим отображения часов.
//************************************************************ Подключаем библиотеки ****************************************************************
#include <DS1307RTC.h>                                                                      //библиотека модуля часов реального времени DS3231
#include <Time.h>                                                                           //библиотека получения информации о текущем времени и дате
#include <TimeLib.h>                                                                        //дополнение к "Time.h" макросы для временных констант и преобразования единиц времени
#include <Wire.h>                                                                           //библиотека I2C
#include <TFT_HX8357.h>                                                                     //подключаем библиотеку для индикатора HX8357
#include <EEPROM.h>                                                                         //подключаем библиотеку EEPROM
#include <Encod_er.h>                                                                       //подключаем библиотеку Encod_er
#include <TimerOne.h>                                                                       //подключаем библиотеку TimerOne
#include <GyverButton.h>                                                                    //подключаем библиотеку для работы с кнопками по количеству нажатий
#include <TonePlayer.h>                                                                     //подключаем библиотеку работы тонального сигнала
#include "Free_Fonts.h"                                                                     //подключаем внешний шрифт Free_Fonts
TFT_HX8357 tft=TFT_HX8357();                                                                //вызываем пользовательскую библиотеку
Encod_er encoder(5,4,4);                                                                    //подключаем энкодер к выводам 5 и 4, 4-время подтверждения состояния сигнала
GButton butt1(8);                                                                           //назначаем порт подключения кнопки энкодера
#define version 9.0                                                                         //корректируем номер версии
#define s "17 October 2019"                                                                 //изменяемая дата создания программы
#define TimeColor 25                                                                        //задержка вывода красным цветом выбранной надписи в режиме навигации
#define del 60                                                                              //скорость вывода надписей заставки и музыкального отрывка
#define NavTime 3500                                                                        //переменная установки времени после которого выходим из навигации по меню без выбора пункта
#define AlarmTime 700                                                                       //переменная установки времени после которого выходим из режима установки будильника
#define Terminal 3                                                                          //назначаем вывод подключения концевого выключателя
#define Gercon 7                                                                            //назначаем вывод подключения датчика положения антенны
#define Beeper 6                                                                            //назначаем вывод подключения пьезоизлучателя
#define Reset 8                                                                             //назначаем вывод подключения кнопки сброса EEPROM
#define Left 11                                                                             //назначаем вывод подключения ключей управления двигатем
#define Right 12                                                                            //------------------------------------------------------
    int pencoder;//******************************************** Назначаем переменные ****** //переменная счётчика энкодера
    word Pencoder;                                                                          //переменная запоминания положения стрелки энкодера
    int lock=0;                                                                             //блокировка энкодера при нахождении в программе часов
    int sensor;                                                                             //переменная датчика положения антенны(геркон)
    word Sensor;                                                                            //переменная запоминания положения датчика антенны(геркон)
    int BEEPER;                                                                             //переменная выбора тона бипера
    int Time;                                                                               //переменная выбора времени задержки в память
    int border;                                                                             //переменная управления цветом окантовки
    int InvDisp;                                                                            //переменная инверсии цвета дисплея
    int RotDisp;                                                                            //переменная управления поворотом изображения
    int flag_encoder=0;                                                                     //флаг равенства счётчиков
    int SetStep=1;                                                                          //флаг разрешения смены надписей "Setting/Step"
    int flag_stop=1;                                                                        //флаг затирания надписи "Stop"
    int flag_Position=0;                                                                    //флаг разрешения индикации предустановок
    int flag_Ememory=0;                                                                     //флаг разрешения записи в EEPROM положения энкодера
    int flag_SEmemory=0;                                                                    //флаг разрешения записи в EEPROM положения датчика и энкодера по окончании движения антенны
    int beepMem=0;                                                                          //флаг звукового подтверждения записи в EEPROM
    int beepCal=0;                                                                          //флаг звукового подтверждения окончания калибровки
    int submenu=0;                                                                          //флаг разрешения входа в подменю
    int single=0;                                                                           //флаг однократного вывода надписей
    int singlealarm=0;                                                                      //флаг однократного звучания будильника
    int singleMem=0;                                                                        //флаг однократной записи в память установленного значения 
    int singlePoint=1;                                                                      //флаг однократного вывода красной точки после выхода из предустановок
    int singleStart=0;                                                                      //флаг однократного вывода надписи "Start"
    int singleStop=0;                                                                       //флаг однократного вывода надписи "Stop"
    int singlePause=0;                                                                      //флаг переключения надписей "Start/Pause"
    int azimuth;                                                                            //переменная выбора азимута для коррекций
    int Set_Step=2;                                                                         //переменная выбора надписей "Setting/Step"
    int Position=0;                                                                         //переменная выбора предустановок
    int SPosition=0;                                                                        //переменная выбора шага датчика
    int BPosition=0;                                                                        //переменная выбора цвета окантовок
    int MPosition=0;                                                                        //переменная выбора времени задержки записи в память
    int NPosition=0;                                                                        //переменная работы с навигацией
    int MReadPos=0;                                                                         //переменная выбора позиции для чтения из памяти
    int MRPos=0;                                                                            //переменная для однократного вывода номеров позиций чтения из памяти
    int bordercolor;                                                                        //переменная выбора цвета окантовок через меню
    int beepMillis=0;                                                                       //начальное значения для счётчика бипера сигнализирующего запись в EEPROM
    int TimeBeep=25;                                                                        //переменная установки длительности звучания бипера сигнализирующего запись в EEPROM
    int valBeep=0;                                                                          //счётчик времени установки длительности звучания бипера
    int TONE;                                                                               //переменная тона звучания бипера
    int valColor=0;                                                                         //счётчик времени вывода надписей красного цвета навигации
    int ColorMillis=0;                                                                      //начальное значение для счётчика времени вывода надписей красного цвета навигации
    int Color=0;                                                                            //переменная разрешения смены цвета при выборе позиции в режиме навигации
    float sx=0,sy=1,ex=0,ey=1;                                                              //переменные крайних координат стрелок
    float sdeg=0,edeg=0;                                                                    //переменные шага стрелок
    int osx=120,osy=120,oex=120,oey=120;                                                    //переменные начальных координат стрелок
    int x0=0,x1=0,yy0=0,yy1=0;                                                              //переменные разбивки шкалы компаса
    int xpos=165;                                                                           //общая координата по x(двигаем весь компас)
    word can,nam,lam,eur,jap,ind,aus,afr;                                                   //переменная предустановок для датчика 360 импульсов
    int can72,nam72,lam72,eur72,jap72,ind72,aus72,afr72;                                    //переменная предустановок для датчика 72 импульса
    int can36,nam36,lam36,eur36,jap36,ind36,aus36,afr36;                                    //переменная предустановок для датчика 36 импульсов
    int can24,nam24,lam24,eur24,jap24,ind24,aus24,afr24;                                    //переменная предустановок для датчика 24 импульса
    int can16,nam16,lam16,eur16,jap16,ind16,aus16,afr16;                                    //переменная предустановок для датчика 16 импульсов
    int stp;                                                                                //переменная ячейки памяти шага датчика движения антенны
    float step,Step;                                                                        //переменные шага движения антенны и рисования точек на компасе
    int number;                                                                             //переменная количества импульсов датчика движения антенны
    boolean GerconWasUp=true;                                                               //переменная исходного состояния датчика положения антенны
    boolean TerminalWasUp=true;                                                             //переменная исходного состояния концевого
    int start=0;                                                                            //переменная разрешения/запрета движения антенны
    int t=968;                                                                              //переменная коррекции хода часов
    uint32_t targetTime=0;                                                                  //для следующего тайм-аута таймера 1 секунда
    uint8_t mmt=0,sst=0;                                                                    //значения минут и секунд таймера
    int Timer=0;                                                                            //переменная управления таймером
    int valClock=0;                                                                         //счётчик времени после которого выводятся часы
    int ClockMillis=0;                                                                      //начальное значение для счётчика времени
    int ClockTime=0;                                                                        //переменная установки времени после которого выводятся часы
    int setclock=0;                                                                         //разрешение входа в режим кореекции часов
    int Clock=0;                                                                            //разрешение вывода часов на основной экран
    int setalarm=0;                                                                         //разрешение входа в режим установки будильника
    int hhalarm,mmalarm,ssalarm=0;                                                          //переменные часов, минут и секунд для будильника
    int alarmonoff=0;                                                                       //переменная включения/выключения будильника
    int nomodule;                                                                           //переменная запрета вызова часов и термометра в отсутствии модуля
    long valNav=0;                                                                          //счётчик времени после которого выходим из навигации по меню без выбора пункта
    long NavMillis=0;                                                                       //начальное значение для счётчика времени
    int music;                                                                              //переменная звукового сопровождения вывода надписей
    int selringtone=0;                                                                      //разрешение входа в режим выбора мелодии
    int select;                                                                             //выбор музыкального фрагмента, если 0- "К Элизе", 1- "Полонез Огинского"
    int direction=0;                                                                        //переменная выбора направления переключения пунктов в установке часов
    int directionAlarm=0;                                                                   //переменная выбора направления переключения пунктов в установке будильника
    int x,y;                                                                                //переменные начальных координат символа колокола
    long valAlarm=0;                                                                        //счётчик времени после которого выходим из режима установки будильника
    long AlarmMillis=0;                                                                     //начальное значение для счётчика времени
    int place=1;                                                                            //переменная выбора пунктов в режиме часов
    float temp3231,TEMP1,TEMP2;                                                             //переменные температуры DS3231
    bool flagtemp=false;                                                                    //флаг смены значений температуры
    byte tMSB,tLSB;                                                                         //переменные измерения температуры модуля DS3231                  
    word music1,music2,music3,music4,music5,music6,music7,music8,music9,music10,music11,    //переменные запоминания в памяти нот
    music12,music13,music14,music15,music16,music17,music18,music19,music20,music21,music22,//-----------------------------------
    music23,music24,music25,music26,music27,music28,music29,music30,music31,music32,music33,//-----------------------------------
    music34,music35,music36,music37,music38,music39,music40,music41,music42,music43,music44,//-----------------------------------
    music45,music46,music47,music48,music49,music50,music51,music52,music53,music54,music55,//-----------------------------------
    music56,music57,music58,music59,music60,music61,music62;                                //-----------------------------------
    byte decToBcd(byte val){return((val/10*16)+(val%10));}                                  //перевод из десятичных чисел в двоичные
    TonePlayer tone4 (TCCR4A,TCCR4B,OCR4AH,OCR4AL,TCNT4H,TCNT4L);                           //вывод тонального сигнала назначаем на D6
void timerInterrupt(){if ((lock==0)||(setclock==1)||(setalarm==1)){encoder.scanState();}    //обработчик прерывания 250 мкс работает
    else cli();}                                                                            //иначе не работает
void setup(){//=========================================== Установочная часть программы =============================================================
    tft.init();                                                                             //инициализация дисплея
    Timer1.initialize(250);                                                                 //инициализация таймера 1, период 250 мкс
    Timer1.attachInterrupt(timerInterrupt,250);                                             //задаем обработчик прерываний
    pinMode(Terminal,INPUT_PULLUP);                                                         //назначаем вывод концевого на вход с внутренней подтяжкой к +5в(3)
    pinMode(Beeper,OUTPUT);                                                                 //назначаем порт пьезоизлучателя на выход(6)(Beeper)
    pinMode(Gercon,INPUT_PULLUP);                                                           //назначаем вывод "Gercon" на вход с внутренней подтяжкой к +5в(7)
    pinMode(Reset,INPUT_PULLUP);                                                            //назначаем вывод "Reset" на вход с внутренней подтяжкой к +5в(8)
    pinMode(Left,OUTPUT);                                                                   //назначаем вывод 11 на выход(движение двигателя против часовой стрелки)
    pinMode(Right,OUTPUT);                                                                  //назначаем вывод 12 на выход(движение двигателя по часовой стрелке)
    digitalWrite(Right,LOW); digitalWrite(Left,LOW);                                        //устанавливаем низкие уровни на управление двигателем при загрузке программы
  if (digitalRead(Reset)==LOW){                                                             //при включении питания с удержанием кнопки "Reset"
    tft.invertDisplay(EEPROM.read(13));                                                     //читаем содержимое ячейки 13 и выводим нормальный или инверсный цвет дисплея
    tft.setRotation(EEPROM.read(14));                                                       //читаем содержимое ячейки 14 и выводим ориентацию дисплея
    border=EEPROM.read(4);                                                                  //читаем из 4 ячейки EEPROM состояние BORDER
  switch (border){                                                                          //оператор выбора цвета окантовок
    case 1: bordercolor=TFT_CYAN; break;                                                    //если border=1 включаем голубой цвет окантовок рамки
    case 2: bordercolor=TFT_ORANGE; break;                                                  //если border=2 включаем оранжевый цвет окантовок рамки
    case 3: bordercolor=tft.color565(40,40,255); break;                                     //если border=3 включаем синий цвет окантовок рамки
    case 4: bordercolor=TFT_SILVER; break;                                                  //если border=4 включаем серебряный цвет окантовок рамки
    case 5: bordercolor=tft.color565(0,170,0); break;                                       //если border=5 включаем пурпурный цвет окантовок рамки
    case 6: bordercolor=TFT_PINK; break;}                                                   //если border=6 включаем розовый цвет окантовок рамки
    tft.fillRoundRect(6,6,468,308,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.setFreeFont(FSBI24);                                                                //подключаем внешний шрифт FSBI24
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("MEMORY RESET",243,103,1);           //выводим подложку надписи "MEMORY RESET"
    tft.setTextColor(TFT_RED); tft.drawCentreString("MEMORY RESET",240,100,1);              //выводим надпись "MEMORY RESET"
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18 и выбираем цвет текста
    tft.drawCentreString(s,240,225,1);                                                      //выводим число, месяц и год создания программы
    tft.drawCentreString("D0ITC",240,260,1);                                                //выводим надпись "D0ITC"
while (digitalRead(Reset)==LOW){}                                                           //ждём отпускания кнопки "Reset"
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("Position N:",180,170,1);            //выводим надпись "Position N:"
  for (int i=0; i<116; i++){delay(250);                                                     //включаем цикл перебора записываемых ячеек памяти
    tft.setTextColor(bordercolor,TFT_GREY40); tft.setTextPadding(80);                       //выбираем цвет и включаем обновление подложки
  switch(i){                                                                                //функция перебора ячеек памяти
    case 0: EEPROM.update(0,0); EEPROM.update(1,0);                                         //записываем,
    Sensor=word(EEPROM.read(0),EEPROM.read(1));                                             //а затем считываем текущее состояние режима
    tft.drawNumber(Sensor,345,170,1); break;                                                //выводим полученное значение "Sensor"
    case 1: EEPROM.update(4,2); border=EEPROM.read(4);                                      //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(border,345,170,1); break;                                                //выводим полученное значение "border"
    case 2: EEPROM.update(5,0); EEPROM.update(6,0);                                         //записываем,
    Pencoder=word(EEPROM.read(5),EEPROM.read(6));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(Pencoder,345,170,1); break;                                              //выводим полученное значение "Sensor"
    case 3: EEPROM.update(13,0); InvDisp=EEPROM.read(13);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(InvDisp,345,170,1); break;                                               //выводим полученное значение "InvDisp"
    case 4: EEPROM.update(14,3); RotDisp=EEPROM.read(14);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(RotDisp,345,170,1); break;                                               //выводим полученное значение "RotDisp"
    case 5: EEPROM.update(15,3); stp=EEPROM.read(15);                                       //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(stp,345,170,1); break;                                                   //выводим полученное значение "stp"
    case 6: EEPROM.update(16,50); ClockTime=EEPROM.read(16);                                //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ClockTime*100,345,170,1); break;                                         //выводим полученное значение "ClockTime"
    case 7: EEPROM.update(17,0); TONE=EEPROM.read(17);                                      //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(TONE,345,170,1); break;                                                  //выводим полученное значение "TONE"
    case 8: EEPROM.update(18,34); can36=EEPROM.read(18);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(can36,345,170,1); break;                                                 //выводим полученное значение "can36"
    case 9: EEPROM.update(19,33); nam36=EEPROM.read(19);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(nam36,345,170,1); break;                                                 //выводим полученное значение "nam36"
    case 10: EEPROM.update(20,31); lam36=EEPROM.read(20);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(lam36,345,170,1); break;                                                 //выводим полученное значение "lam36"
    case 11: EEPROM.update(21,29); eur36=EEPROM.read(21);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(eur36,345,170,1); break;                                                 //выводим полученное значение "eur36"
    case 12: EEPROM.update(22,6); jap36=EEPROM.read(22);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(jap36,345,170,1); break;                                                 //выводим полученное значение "jap36"
    case 13: EEPROM.update(23,11); ind36=EEPROM.read(23);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ind36,345,170,1); break;                                                 //выводим полученное значение "ind36"
    case 14: EEPROM.update(24,10); aus36=EEPROM.read(24);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(aus36,345,170,1); break;                                                 //выводим полученное значение "aus36"
    case 15: EEPROM.update(25,20); afr36=EEPROM.read(25);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(afr36,345,170,1); break;                                                 //выводим полученное значение "afr36"
    case 16: EEPROM.update(26,23); can24=EEPROM.read(26);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(can24,345,170,1); break;                                                 //выводим полученное значение "can24"
    case 17: EEPROM.update(27,22); nam24=EEPROM.read(27);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(nam24,345,170,1); break;                                                 //выводим полученное значение "nam24"
    case 18: EEPROM.update(28,21); lam24=EEPROM.read(28);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(lam24,345,170,1); break;                                                 //выводим полученное значение "lam24"
    case 19: EEPROM.update(29,19); eur24=EEPROM.read(29);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(eur24,345,170,1); break;                                                 //выводим полученное значение "eur24"
    case 20: EEPROM.update(30,4); jap24=EEPROM.read(30);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(jap24,345,170,1); break;                                                 //выводим полученное значение "jap24"
    case 21: EEPROM.update(31,8); ind24=EEPROM.read(31);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ind24,345,170,1); break;                                                 //выводим полученное значение "ind24"
    case 22: EEPROM.update(32,7); aus24=EEPROM.read(32);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(aus24,345,170,1); break;                                                 //выводим полученное значение "aus24"
    case 23: EEPROM.update(33,13); afr24=EEPROM.read(33);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(afr24,345,170,1); break;                                                 //выводим полученное значение "afr24"
    case 24: EEPROM.update(34,15); can16=EEPROM.read(34);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(can16,345,170,1); break;                                                 //выводим полученное значение "can16"
    case 25: EEPROM.update(35,14); nam16=EEPROM.read(35);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(nam16,345,170,1); break;                                                 //выводим полученное значение "nam16"
    case 26: EEPROM.update(36,13); lam16=EEPROM.read(36);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(lam16,345,170,1); break;                                                 //выводим полученное значение "lam16"
    case 27: EEPROM.update(37,12); eur16=EEPROM.read(37);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(eur16,345,170,1); break;                                                 //выводим полученное значение "eur16"
    case 28: EEPROM.update(38,3); jap16=EEPROM.read(38);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(jap16,345,170,1); break;                                                 //выводим полученное значение "jap16"
    case 29: EEPROM.update(39,5); ind16=EEPROM.read(39);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ind16,345,170,1); break;                                                 //выводим полученное значение "ind16"
    case 30: EEPROM.update(40,4); aus16=EEPROM.read(40);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(aus16,345,170,1); break;                                                 //выводим полученное значение "aus16"
    case 31: EEPROM.update(41,9); afr16=EEPROM.read(41);                                    //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(afr16,345,170,1); break;                                                 //выводим полученное значение "afr16"
    case 32: EEPROM.update(42,highByte(339)); EEPROM.update(43,lowByte(339));               //записываем,
    can=word(EEPROM.read(42),EEPROM.read(43));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(can,345,170,1); break;                                                   //выводим полученное значение "can"
    case 33: EEPROM.update(44,highByte(333)); EEPROM.update(45,lowByte(333));               //записываем,
    nam=word(EEPROM.read(44),EEPROM.read(45));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(nam,345,170,1); break;                                                   //выводим полученное значение "nam"
    case 34: EEPROM.update(46,highByte(315)); EEPROM.update(47,lowByte(315));               //записываем,
    lam=word(EEPROM.read(46),EEPROM.read(47));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(lam,345,170,1); break;                                                   //выводим полученное значение "lam"
    case 35: EEPROM.update(48,highByte(290)); EEPROM.update(49,lowByte(290));               //записываем,
    eur=word(EEPROM.read(48),EEPROM.read(49));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(eur,345,170,1); break;                                                   //выводим полученное значение "eur"
    case 36: EEPROM.update(50,highByte(58)); EEPROM.update(51,lowByte(58));                 //записываем,
    jap=word(EEPROM.read(50),EEPROM.read(51));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(jap,345,170,1); break;                                                   //выводим полученное значение "jap"
    case 37: EEPROM.update(52,highByte(114)); EEPROM.update(53,lowByte(114));               //записываем,
    ind=word(EEPROM.read(52),EEPROM.read(53));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(ind,345,170,1); break;                                                   //выводим полученное значение "ind"
    case 38: EEPROM.update(54,highByte(105)); EEPROM.update(55,lowByte(105));               //записываем,
    aus=word(EEPROM.read(54),EEPROM.read(55));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(aus,345,170,1); break;                                                   //выводим полученное значение "aus"
    case 39: EEPROM.update(56,highByte(202)); EEPROM.update(57,lowByte(202));               //записываем,
    afr=word(EEPROM.read(56),EEPROM.read(57));                                              //а затем считываем текущее состояние режима
    tft.drawNumber(afr,345,170,1); break;                                                   //выводим полученное значение "afr"
    case 40: EEPROM.update(58,68); can72=EEPROM.read(58);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(can72,345,170,1); break;                                                 //выводим полученное значение "can72"
    case 41: EEPROM.update(59,67); nam72=EEPROM.read(59);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(nam72,345,170,1); break;                                                 //выводим полученное значение "nam72"
    case 42: EEPROM.update(60,63); lam72=EEPROM.read(60);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(lam72,345,170,1); break;                                                 //выводим полученное значение "lam72"
    case 43: EEPROM.update(61,58); eur72=EEPROM.read(61);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(eur72,345,170,1); break;                                                 //выводим полученное значение "eur72"
    case 44: EEPROM.update(62,12); jap72=EEPROM.read(62);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(eur72,345,170,1); break;                                                 //выводим полученное значение "jap72"
    case 45: EEPROM.update(63,23); ind72=EEPROM.read(63);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ind72,345,170,1); break;                                                 //выводим полученное значение "ind72"
    case 46: EEPROM.update(64,21); aus72=EEPROM.read(64);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(aus72,345,170,1); break;                                                 //выводим полученное значение "aus72"
    case 47: EEPROM.update(65,41); afr72=EEPROM.read(65);                                   //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(afr72,345,170,1); break;                                                 //выводим полученное значение "afr72"
    case 48: EEPROM.update(66,highByte(659)); EEPROM.update(67,lowByte(659));               //записываем,
    music1=word(EEPROM.read(66),EEPROM.read(67));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music1,345,170,1); break;                                                //выводим полученное значение "music1"
    case 49: EEPROM.update(68,highByte(659)); EEPROM.update(69,lowByte(659));               //записываем,
    music2=word(EEPROM.read(68),EEPROM.read(69));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music2,345,170,1); break;                                                //выводим полученное значение "music2"
    case 50: EEPROM.update(70,highByte(659)); EEPROM.update(71,lowByte(659));               //записываем,
    music3=word(EEPROM.read(70),EEPROM.read(71));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music3,345,170,1); break;                                                //выводим полученное значение "music3"
    case 51: EEPROM.update(72,highByte(622)); EEPROM.update(73,lowByte(622));               //записываем,
    music4=word(EEPROM.read(72),EEPROM.read(73));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music4,345,170,1); break;                                                //выводим полученное значение "music4"
    case 52: EEPROM.update(74,highByte(622)); EEPROM.update(75,lowByte(622));               //записываем,
    music5=word(EEPROM.read(74),EEPROM.read(75));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music5,345,170,1); break;                                                //выводим полученное значение "music5"
    case 53: EEPROM.update(76,highByte(622)); EEPROM.update(77,lowByte(622));               //записываем,
    music6=word(EEPROM.read(76),EEPROM.read(77));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music6,345,170,1); break;                                                //выводим полученное значение "music6"
    case 54: EEPROM.update(78,highByte(659)); EEPROM.update(79,lowByte(659));               //записываем,
    music7=word(EEPROM.read(78),EEPROM.read(79));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music7,345,170,1); break;                                                //выводим полученное значение "music7"
    case 55: EEPROM.update(80,highByte(659)); EEPROM.update(81,lowByte(659));               //записываем,
    music8=word(EEPROM.read(80),EEPROM.read(81));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music8,345,170,1); break;                                                //выводим полученное значение "music8"
    case 56: EEPROM.update(82,highByte(659)); EEPROM.update(83,lowByte(659));               //записываем,
    music9=word(EEPROM.read(82),EEPROM.read(83));                                           //а затем считываем текущее состояние режима
    tft.drawNumber(music9,345,170,1); break;                                                //выводим полученное значение "music9"
    case 57: EEPROM.update(84,highByte(622)); EEPROM.update(85,lowByte(622));               //записываем,
    music10=word(EEPROM.read(84),EEPROM.read(85));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music10,345,170,1); break;                                               //выводим полученное значение "music10"
    case 58: EEPROM.update(86,highByte(622)); EEPROM.update(87,lowByte(622));               //записываем,
    music11=word(EEPROM.read(86),EEPROM.read(87));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music11,345,170,1); break;                                               //выводим полученное значение "music11"
    case 59: EEPROM.update(88,highByte(622)); EEPROM.update(89,lowByte(622));               //записываем,
    music12=word(EEPROM.read(88),EEPROM.read(89));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music12,345,170,1); break;                                               //выводим полученное значение "music12"
    case 60: EEPROM.update(90,highByte(659)); EEPROM.update(91,lowByte(659));               //записываем,
    music13=word(EEPROM.read(90),EEPROM.read(91));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music13,345,170,1); break;                                               //выводим полученное значение "music13"
    case 61: EEPROM.update(92,highByte(659)); EEPROM.update(93,lowByte(659));               //записываем,
    music14=word(EEPROM.read(92),EEPROM.read(93));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music14,345,170,1); break;                                               //выводим полученное значение "music14"
    case 62: EEPROM.update(94,highByte(659)); EEPROM.update(95,lowByte(659));               //записываем,
    music15=word(EEPROM.read(94),EEPROM.read(95));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music15,345,170,1); break;                                               //выводим полученное значение "music15"
    case 63: EEPROM.update(96,highByte(494)); EEPROM.update(97,lowByte(494));               //записываем,
    music16=word(EEPROM.read(96),EEPROM.read(97));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music16,345,170,1); break;                                               //выводим полученное значение "music16"
    case 64: EEPROM.update(98,highByte(494)); EEPROM.update(99,lowByte(494));               //записываем,
    music17=word(EEPROM.read(98),EEPROM.read(99));                                          //а затем считываем текущее состояние режима
    tft.drawNumber(music17,345,170,1); break;                                               //выводим полученное значение "music17"
    case 65: EEPROM.update(100,highByte(494)); EEPROM.update(101,lowByte(494));             //записываем,
    music18=word(EEPROM.read(100),EEPROM.read(101));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music18,345,170,1); break;                                               //выводим полученное значение "music18"
    case 66: EEPROM.update(102,highByte(587)); EEPROM.update(103,lowByte(587));             //записываем,
    music19=word(EEPROM.read(102),EEPROM.read(103));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music19,345,170,1); break;                                               //выводим полученное значение "music19"
    case 67: EEPROM.update(104,highByte(587)); EEPROM.update(105,lowByte(587));             //записываем,
    music20=word(EEPROM.read(104),EEPROM.read(105));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music20,345,170,1); break;                                               //выводим полученное значение "music20"
    case 68: EEPROM.update(106,highByte(587)); EEPROM.update(107,lowByte(587));             //записываем,
    music21=word(EEPROM.read(106),EEPROM.read(107));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music21,345,170,1); break;                                               //выводим полученное значение "music21"
    case 69: EEPROM.update(108,highByte(523)); EEPROM.update(109,lowByte(523));             //записываем,
    music22=word(EEPROM.read(108),EEPROM.read(109));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music22,345,170,1); break;                                               //выводим полученное значение "music22"
    case 70: EEPROM.update(110,highByte(523)); EEPROM.update(111,lowByte(523));             //записываем,
    music23=word(EEPROM.read(110),EEPROM.read(111));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music23,345,170,1); break;                                               //выводим полученное значение "music23"
    case 71: EEPROM.update(112,highByte(523)); EEPROM.update(113,lowByte(523));             //записываем,
    music24=word(EEPROM.read(112),EEPROM.read(113));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music24,345,170,1); break;                                               //выводим полученное значение "music24"
    case 72: EEPROM.update(114,highByte(0)); EEPROM.update(115,lowByte(0));                 //записываем,
    music25=word(EEPROM.read(114),EEPROM.read(115));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music25,345,170,1); break;                                               //выводим полученное значение "music25"
    case 73: EEPROM.update(116,highByte(440)); EEPROM.update(117,lowByte(440));             //записываем,
    music26=word(EEPROM.read(116),EEPROM.read(117));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music26,345,170,1); break;                                               //выводим полученное значение "music26"
    case 74: EEPROM.update(118,highByte(440)); EEPROM.update(119,lowByte(440));             //записываем,
    music27=word(EEPROM.read(118),EEPROM.read(119));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music27,345,170,1); break;                                               //выводим полученное значение "music27"
    case 75: EEPROM.update(120,highByte(440)); EEPROM.update(121,lowByte(440));             //записываем,
    music28=word(EEPROM.read(120),EEPROM.read(121));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music28,345,170,1); break;                                               //выводим полученное значение "music28"
    case 76: EEPROM.update(122,highByte(440)); EEPROM.update(123,lowByte(440));             //записываем,
    music29=word(EEPROM.read(122),EEPROM.read(123));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music29,345,170,1); break;                                               //выводим полученное значение "music29"
    case 77: EEPROM.update(124,highByte(440)); EEPROM.update(125,lowByte(440));             //записываем,
    music30=word(EEPROM.read(124),EEPROM.read(125));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music30,345,170,1); break;                                               //выводим полученное значение "music30"
    case 78: EEPROM.update(126,highByte(440)); EEPROM.update(127,lowByte(440));             //записываем,
    music31=word(EEPROM.read(126),EEPROM.read(127));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music31,345,170,1); break;                                               //выводим полученное значение "music31"
    case 79: EEPROM.update(128,highByte(440)); EEPROM.update(129,lowByte(440));             //записываем,
    music32=word(EEPROM.read(128),EEPROM.read(129));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music32,345,170,1); break;                                               //выводим полученное значение "music32"
    case 80: EEPROM.update(130,highByte(440)); EEPROM.update(131,lowByte(440));             //записываем,
    music33=word(EEPROM.read(130),EEPROM.read(131));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music33,345,170,1); break;                                               //выводим полученное значение "music33"
    case 81: EEPROM.update(132,highByte(440)); EEPROM.update(133,lowByte(440));             //записываем,
    music34=word(EEPROM.read(132),EEPROM.read(133));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music34,345,170,1); break;                                               //выводим полученное значение "music34"
    case 82: EEPROM.update(134,highByte(440)); EEPROM.update(135,lowByte(440));             //записываем,
    music35=word(EEPROM.read(134),EEPROM.read(135));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music35,345,170,1); break;                                               //выводим полученное значение "music35"
    case 83: EEPROM.update(136,highByte(0)); EEPROM.update(137,lowByte(0));                 //записываем,
    music36=word(EEPROM.read(136),EEPROM.read(137));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music36,345,170,1); break;                                               //выводим полученное значение "music36"
    case 84: EEPROM.update(138,highByte(415)); EEPROM.update(139,lowByte(415));             //записываем,
    music37=word(EEPROM.read(138),EEPROM.read(139));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music37,345,170,1); break;                                               //выводим полученное значение "music37"
    case 85: EEPROM.update(140,highByte(415)); EEPROM.update(141,lowByte(415));             //записываем,
    music38=word(EEPROM.read(140),EEPROM.read(141));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music38,345,170,1); break;                                               //выводим полученное значение "music38"
    case 86: EEPROM.update(142,highByte(440)); EEPROM.update(143,lowByte(440));             //записываем,
    music39=word(EEPROM.read(142),EEPROM.read(143));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music39,345,170,1); break;                                               //выводим полученное значение "music39"
    case 87: EEPROM.update(144,highByte(440)); EEPROM.update(145,lowByte(440));             //записываем,
    music40=word(EEPROM.read(144),EEPROM.read(145));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music40,345,170,1); break;                                               //выводим полученное значение "music40"
    case 88: EEPROM.update(146,highByte(463)); EEPROM.update(147,lowByte(463));             //записываем,
    music41=word(EEPROM.read(146),EEPROM.read(147));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music41,345,170,1); break;                                               //выводим полученное значение "music41"
    case 89: EEPROM.update(148,highByte(463)); EEPROM.update(149,lowByte(463));             //записываем,
    music42=word(EEPROM.read(148),EEPROM.read(149));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music42,345,170,1); break;                                               //выводим полученное значение "music42"
    case 90: EEPROM.update(150,highByte(463)); EEPROM.update(151,lowByte(463));             //записываем,
    music43=word(EEPROM.read(150),EEPROM.read(151));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music43,345,170,1); break;                                               //выводим полученное значение "music43"
    case 91: EEPROM.update(152,highByte(440)); EEPROM.update(153,lowByte(440));             //записываем,
    music44=word(EEPROM.read(152),EEPROM.read(153));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music44,345,170,1); break;                                               //выводим полученное значение "music44"
    case 92: EEPROM.update(154,highByte(440)); EEPROM.update(155,lowByte(440));             //записываем,
    music45=word(EEPROM.read(154),EEPROM.read(155));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music45,345,170,1); break;                                               //выводим полученное значение "music45"
    case 93: EEPROM.update(156,highByte(440)); EEPROM.update(157,lowByte(440));             //записываем,
    music46=word(EEPROM.read(156),EEPROM.read(157));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music46,345,170,1); break;                                               //выводим полученное значение "music46"
    case 94: EEPROM.update(158,highByte(349)); EEPROM.update(159,lowByte(349));             //записываем,
    music47=word(EEPROM.read(158),EEPROM.read(159));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music47,345,170,1); break;                                               //выводим полученное значение "music47"
    case 95: EEPROM.update(160,highByte(349)); EEPROM.update(161,lowByte(349));             //записываем,
    music48=word(EEPROM.read(160),EEPROM.read(161));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music48,345,170,1); break;                                               //выводим полученное значение "music48"
    case 96: EEPROM.update(162,highByte(349)); EEPROM.update(163,lowByte(349));             //записываем,
    music49=word(EEPROM.read(162),EEPROM.read(163));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music49,345,170,1); break;                                               //выводим полученное значение "music49"
    case 97: EEPROM.update(164,highByte(349)); EEPROM.update(165,lowByte(349));             //записываем,
    music50=word(EEPROM.read(164),EEPROM.read(165));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music50,345,170,1); break;                                               //выводим полученное значение "music50"
    case 98: EEPROM.update(166,highByte(0)); EEPROM.update(167,lowByte(0));                 //записываем,
    music51=word(EEPROM.read(166),EEPROM.read(167));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music51,345,170,1); break;                                               //выводим полученное значение "music51"
    case 99: EEPROM.update(168,highByte(349)); EEPROM.update(169,lowByte(349));             //записываем,
    music52=word(EEPROM.read(168),EEPROM.read(169));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music52,345,170,1); break;                                               //выводим полученное значение "music52"
    case 100: EEPROM.update(170,highByte(349)); EEPROM.update(171,lowByte(349));            //записываем,
    music53=word(EEPROM.read(170),EEPROM.read(171));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music53,345,170,1); break;                                               //выводим полученное значение "music53"
    case 101: EEPROM.update(172,highByte(330)); EEPROM.update(173,lowByte(330));            //записываем,
    music54=word(EEPROM.read(172),EEPROM.read(173));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music54,345,170,1); break;                                               //выводим полученное значение "music54"
    case 102: EEPROM.update(174,highByte(330)); EEPROM.update(175,lowByte(330));            //записываем,
    music55=word(EEPROM.read(174),EEPROM.read(175));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music55,345,170,1); break;                                               //выводим полученное значение "music55"
    case 103: EEPROM.update(176,highByte(0)); EEPROM.update(177,lowByte(0));                //записываем,
    music56=word(EEPROM.read(176),EEPROM.read(177));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music56,345,170,1); break;                                               //выводим полученное значение "music56"
    case 104: EEPROM.update(178,highByte(294)); EEPROM.update(179,lowByte(294));            //записываем,
    music57=word(EEPROM.read(178),EEPROM.read(179));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music57,345,170,1); break;                                               //выводим полученное значение "music57"
    case 105: EEPROM.update(180,highByte(294)); EEPROM.update(181,lowByte(294));            //записываем,
    music58=word(EEPROM.read(180),EEPROM.read(181));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music58,345,170,1); break;                                               //выводим полученное значение "music58"
    case 106: EEPROM.update(182,highByte(294)); EEPROM.update(183,lowByte(294));            //записываем,
    music59=word(EEPROM.read(182),EEPROM.read(183));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music59,345,170,1); break;                                               //выводим полученное значение "music59"
    case 107: EEPROM.update(184,highByte(294)); EEPROM.update(185,lowByte(294));            //записываем,
    music60=word(EEPROM.read(184),EEPROM.read(185));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music60,345,170,1); break;                                               //выводим полученное значение "music60"
    case 108: EEPROM.update(186,highByte(349)); EEPROM.update(187,lowByte(349));            //записываем,
    music61=word(EEPROM.read(186),EEPROM.read(187));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music61,345,170,1); break;                                               //выводим полученное значение "music61"
    case 109: EEPROM.update(188,highByte(349)); EEPROM.update(189,lowByte(349));            //записываем,
    music62=word(EEPROM.read(188),EEPROM.read(189));                                        //а затем считываем текущее состояние режима
    tft.drawNumber(music62,345,170,1); break;                                               //выводим полученное значение "music62"
    case 110: EEPROM.update(190,0); select=EEPROM.read(190);                                //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(select,345,170,1); break;                                                //выводим полученное значение "select"
    case 111: EEPROM.update(191,0); hhalarm=EEPROM.read(191);                               //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(hhalarm,345,170,1); break;                                               //выводим полученное значение "hhalarm"
    case 112: EEPROM.update(192,0); mmalarm=EEPROM.read(192);                               //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(mmalarm,345,170,1); break;                                               //выводим полученное значение "mmalarm"
    case 113: EEPROM.update(193,0); ssalarm=EEPROM.read(193);                               //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(ssalarm,345,170,1); break;                                               //выводим полученное значение "ssalarm"
    case 114: EEPROM.update(194,0); alarmonoff=EEPROM.read(194);                            //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(alarmonoff,345,170,1); break;                                            //выводим полученное значение "alarmonoff"
    case 115: EEPROM.update(195,0); Clock=EEPROM.read(195);                                 //записываем, а затем считываем текущее состояние режима
    tft.drawNumber(Clock,345,170,1); break;}                                                //выводим полученное значение "Clock"
    tft.setTextColor(TFT_SILVER,TFT_GREY40); tft.setTextPadding(40);                        //выбираем цвет и включаем обновление подложки
    tft.drawNumber(i,270,170,1);}                                                           //выводим номера ячеек памяти
    delay(1000);                                                                            //задержка на вывод номеров ячеек памяти
    tft.fillRect(40,99,400,110,TFT_GREY40);                                                 //затираем предыдущие надписи
    tft.setFreeFont(FSBI24);                                                                //подключаем внешний шрифт FSBI24
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("RESET OK",243,103,1);               //выводим подложку надписи "RESET OK"
    tft.setTextColor(TFT_RED); tft.drawCentreString("RESET OK",240,100,1);                  //выводим надпись "RESET OK"
    delay(1000);}                                                                           //задержка на вывод надписи об окончании сброса EEPROM
    border=EEPROM.read(4);                                                                  //читаем из 4 ячейки EEPROM состояние BORDER
    hhalarm=EEPROM.read(191);                                                               //читаем значение часов для будильника
    mmalarm=EEPROM.read(192);                                                               //читаем значение минут для будильника
    ssalarm=EEPROM.read(193);                                                               //читаем значение секунд для будильника
    alarmonoff=EEPROM.read(194);                                                            //читаем состояние будильника
    Clock=EEPROM.read(195);                                                                 //читаем разрешен ли вывод часов в основной программе
  switch(border){                                                                           //функция выбора цвета окантовок
  case 1: bordercolor=TFT_CYAN; break;                                                      //если border=1 включается голубой цвет окантовки  рамок
  case 2: bordercolor=TFT_ORANGE; break;                                                    //если border=2 включается оранжевый цвет окантовки рамок
  case 3: bordercolor=tft.color565(40,40,255); break;                                       //если border=3 включаем синий цвет окантовок рамки
  case 4: bordercolor=TFT_SILVER; break;                                                    //если border=4 включаем серебряный цвет окантовок рамки
  case 5: bordercolor=tft.color565(0,170,0); break;                                         //если border=5 включаем зелёный цвет окантовок рамки
  case 6: bordercolor=TFT_PINK; break;}                                                     //если border=6 включаем розовый цвет окантовок рамки
    TONE=EEPROM.read(17);                                                                   //читаем ячейки EEPROM при загрузке программы
    Sensor  =word(EEPROM.read(0),EEPROM.read(1)); sensor=Sensor;                            //-------------------------------------------
    Pencoder=word(EEPROM.read(5),EEPROM.read(6)); pencoder=Pencoder;                        //-------------------------------------------
    tft.invertDisplay(EEPROM.read(13));                                                     //читаем содержимое ячейки 13 и выводим нормальный или инверсный цвет дисплея
    tft.setRotation(EEPROM.read(14));                                                       //читаем содержимое ячейки 14 и выводим ориентацию дисплея
    tft.fillRoundRect(6,6,468,308,8,TFT_GREY40);//************************* Заставка ****** //рисуем тёмно серый прямоугольник фона
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18 и выбираем цвет текста
    tft.drawCentreString(s,235,265,1);                                                      //выводим число, месяц и год создания программы
    tft.setFreeFont(FSBI24);                                                                //подключаем внешний шрифт FSBI24
    tft.setTextColor(TFT_DARKGREY); tft.drawString("v-",183,153,1);                         //выводим подложку надписи "v-"
    tft.setTextColor(TFT_RED); tft.drawString("v-",180,150,1);                              //и надпись "v-"
    tft.setTextColor(TFT_DARKGREY); tft.drawFloat(version,1,223,153,1);                     //выводим подложку номера версии
    tft.setTextColor(TFT_RED); tft.drawFloat(version,1,220,150,1);                          //выводим номер версии
    select=EEPROM.read(190);                                                                //читаем выбранный рингтон
  if (select==0){                                                                           //если "select==0"
    music1=word(EEPROM.read(66),EEPROM.read(67));                                           //читаем из памяти ноты рингтона "К Элизе"
    music2=word(EEPROM.read(68),EEPROM.read(69));                                           //----------------------------------------
    music3=word(EEPROM.read(70),EEPROM.read(71));                                           //----------------------------------------
    music4=word(EEPROM.read(72),EEPROM.read(73));                                           //----------------------------------------
    music5=word(EEPROM.read(74),EEPROM.read(75));                                           //----------------------------------------
    music6=word(EEPROM.read(76),EEPROM.read(77));                                           //----------------------------------------
    music7=word(EEPROM.read(78),EEPROM.read(79));                                           //----------------------------------------
    music8=word(EEPROM.read(80),EEPROM.read(81));                                           //----------------------------------------
    music9=word(EEPROM.read(82),EEPROM.read(83));                                           //----------------------------------------
    music10=word(EEPROM.read(84),EEPROM.read(85));                                          //----------------------------------------
    music11=word(EEPROM.read(86),EEPROM.read(87));                                          //----------------------------------------
    music12=word(EEPROM.read(88),EEPROM.read(89));                                          //----------------------------------------
    music13=word(EEPROM.read(90),EEPROM.read(91));                                          //----------------------------------------
    music14=word(EEPROM.read(92),EEPROM.read(93));                                          //----------------------------------------
    music15=word(EEPROM.read(94),EEPROM.read(95));                                          //----------------------------------------
    music16=word(EEPROM.read(96),EEPROM.read(97));                                          //----------------------------------------
    music17=word(EEPROM.read(98),EEPROM.read(99));                                          //----------------------------------------
    music18=word(EEPROM.read(100),EEPROM.read(101));                                        //----------------------------------------
    music19=word(EEPROM.read(102),EEPROM.read(103));                                        //----------------------------------------
    music20=word(EEPROM.read(104),EEPROM.read(105));                                        //----------------------------------------
    music21=word(EEPROM.read(106),EEPROM.read(107));                                        //----------------------------------------
    music22=word(EEPROM.read(108),EEPROM.read(109));                                        //----------------------------------------
    music23=word(EEPROM.read(110),EEPROM.read(111));                                        //----------------------------------------
    music24=word(EEPROM.read(112),EEPROM.read(113));                                        //----------------------------------------
    music25=word(EEPROM.read(114),EEPROM.read(115));                                        //----------------------------------------
    music26=word(EEPROM.read(116),EEPROM.read(117));                                        //----------------------------------------
    music27=word(EEPROM.read(118),EEPROM.read(119));                                        //----------------------------------------
    music28=word(EEPROM.read(120),EEPROM.read(121));                                        //----------------------------------------
    music29=word(EEPROM.read(122),EEPROM.read(123));                                        //----------------------------------------
    music30=word(EEPROM.read(124),EEPROM.read(125));                                        //----------------------------------------
    music31=word(EEPROM.read(126),EEPROM.read(127));}                                       //----------------------------------------
  if (select==1){                                                                           //если "select==1"
    music32=word(EEPROM.read(128),EEPROM.read(129));                                        //читаем из памяти ноты рингтона "Полонез Огинского"
    music33=word(EEPROM.read(130),EEPROM.read(131));                                        //--------------------------------------------------
    music34=word(EEPROM.read(132),EEPROM.read(133));                                        //--------------------------------------------------
    music35=word(EEPROM.read(134),EEPROM.read(135));                                        //--------------------------------------------------
    music36=word(EEPROM.read(136),EEPROM.read(137));                                        //--------------------------------------------------
    music37=word(EEPROM.read(138),EEPROM.read(139));                                        //--------------------------------------------------
    music38=word(EEPROM.read(140),EEPROM.read(141));                                        //--------------------------------------------------
    music39=word(EEPROM.read(142),EEPROM.read(143));                                        //--------------------------------------------------
    music40=word(EEPROM.read(144),EEPROM.read(145));                                        //--------------------------------------------------
    music41=word(EEPROM.read(146),EEPROM.read(147));                                        //--------------------------------------------------
    music42=word(EEPROM.read(148),EEPROM.read(149));                                        //--------------------------------------------------
    music43=word(EEPROM.read(150),EEPROM.read(151));                                        //--------------------------------------------------
    music44=word(EEPROM.read(152),EEPROM.read(153));                                        //--------------------------------------------------
    music45=word(EEPROM.read(154),EEPROM.read(155));                                        //--------------------------------------------------
    music46=word(EEPROM.read(156),EEPROM.read(157));                                        //--------------------------------------------------
    music47=word(EEPROM.read(158),EEPROM.read(159));                                        //--------------------------------------------------
    music48=word(EEPROM.read(160),EEPROM.read(161));                                        //--------------------------------------------------
    music49=word(EEPROM.read(162),EEPROM.read(163));                                        //--------------------------------------------------
    music50=word(EEPROM.read(164),EEPROM.read(165));                                        //--------------------------------------------------
    music51=word(EEPROM.read(166),EEPROM.read(167));                                        //--------------------------------------------------
    music52=word(EEPROM.read(168),EEPROM.read(169));                                        //--------------------------------------------------
    music53=word(EEPROM.read(170),EEPROM.read(171));                                        //--------------------------------------------------
    music54=word(EEPROM.read(172),EEPROM.read(173));                                        //--------------------------------------------------
    music55=word(EEPROM.read(174),EEPROM.read(175));                                        //--------------------------------------------------
    music56=word(EEPROM.read(176),EEPROM.read(177));                                        //--------------------------------------------------
    music57=word(EEPROM.read(178),EEPROM.read(179));                                        //--------------------------------------------------
    music58=word(EEPROM.read(180),EEPROM.read(181));                                        //--------------------------------------------------
    music59=word(EEPROM.read(182),EEPROM.read(183));                                        //--------------------------------------------------
    music60=word(EEPROM.read(184),EEPROM.read(185));                                        //--------------------------------------------------
    music61=word(EEPROM.read(186),EEPROM.read(187));                                        //--------------------------------------------------
    music62=word(EEPROM.read(188),EEPROM.read(189));}                                       //--------------------------------------------------
  for(int i=0; i<12; i++){                                                                  //цикл вывода подложки и надписи "Azimuthal" и "rotary device"
  switch(i){                                                                                //------------------------------------------------------------
    case 0: tft.setTextColor(TFT_DARKGREY); tft.drawString("A",133,53,1);                   //------------------------------------------------------------
            tft.drawString("D",160,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("A",130,50,1); break;                 //------------------------------------------------------------
    case 1: tft.setTextColor(TFT_DARKGREY); tft.drawString("z",166,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("z",163,50,1); break;                 //------------------------------------------------------------
    case 2: tft.setTextColor(TFT_DARKGREY); tft.drawString("i",187,53,1);                   //------------------------------------------------------------
            tft.drawString("0",200,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("i",184,50,1); break;                 //------------------------------------------------------------
    case 3: tft.setTextColor(TFT_DARKGREY); tft.drawString("m",203,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("m",200,50,1); break;                 //------------------------------------------------------------
    case 4: tft.setTextColor(TFT_DARKGREY); tft.drawString("u",241,53,1);                   //------------------------------------------------------------
            tft.drawString("I",222,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("u",238,50,1); break;                 //------------------------------------------------------------
    case 5: tft.setTextColor(TFT_DARKGREY); tft.drawString("t",268,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("t",265,50,1); break;                 //------------------------------------------------------------
    case 6: tft.setTextColor(TFT_DARKGREY); tft.drawString("h",283,53,1);                   //------------------------------------------------------------
            tft.drawString("T",240,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("h",280,50,1); break;                 //------------------------------------------------------------
    case 7: tft.setTextColor(TFT_DARKGREY); tft.drawString("a",310,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("a",307,50,1); break;                 //------------------------------------------------------------
    case 8: tft.setTextColor(TFT_DARKGREY); tft.drawString("l",333,53,1);                   //------------------------------------------------------------
            tft.drawString("C",273,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("l",330,50,1); break;}                //------------------------------------------------------------
  switch(i){                                                                                //------------------------------------------------------------
    case 0: if (select==0){music=music1;} if (select==1){music=music32;}                    //взависимости от выбранного рингтона включаем тон соответствующей высоты
            tft.setTextColor(TFT_DARKGREY); tft.drawString("r",113,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("r",110,100,1); break;                //------------------------------------------------------------
    case 1: if (select==0){music=music2;} if (select==1){music=music33;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("o",133,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("o",130,100,1); break;                //------------------------------------------------------------
    case 2: if (select==0){music=music3;} if (select==1){music=music34;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("t",156,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("t",153,100,1); break;                //------------------------------------------------------------
    case 3: if (select==0){music=music4;} if (select==1){music=music35;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("a",172,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("a",169,100,1); break;                //------------------------------------------------------------
    case 4: if (select==0){music=music5;} if (select==1){music=music36;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("r",195,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("r",192,100,1); break;                //------------------------------------------------------------
    case 5: if (select==0){music=music6;} if (select==1){music=music37;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("y",215,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("y",212,100,1); break;                //------------------------------------------------------------
    case 6: if (select==0){music=music7;} if (select==1){music=music38;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("d",248,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("d",245,100,1); break;                //------------------------------------------------------------
    case 7: if (select==0){music=music8;} if (select==1){music=music39;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("e",272,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("e",269,100,1); break;                //------------------------------------------------------------
    case 8: if (select==0){music=music9;} if (select==1){music=music40;}                    //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("v",290,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("v",287,100,1); break;                //------------------------------------------------------------
    case 9: if (select==0){music=music10;} if (select==1){music=music41;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("i",312,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("i",309,100,1); break;                //------------------------------------------------------------
    case 10:if (select==0){music=music11;} if (select==1){music=music42;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("c",324,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("c",321,100,1); break;                //------------------------------------------------------------
    case 11:if (select==0){music=music12;} if (select==1){music=music43;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("e",342,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("e",339,100,1); break;}               //------------------------------------------------------------
  if (TONE!=0){tone4.tone(music);} delay(del); tone4.noTone();}                             //если разрешен бипер выводим надписи со звуком справа налево с задержкой "del"
    tft.fillRect(130,47,220,45,TFT_GREY40);                                                 //затираем предыдущее изображение
    tft.fillRect(105,97,260,48,TFT_GREY40);                                                 //-------------------------------
    tft.fillRect(155,220,160,43,TFT_GREY40);                                                //-------------------------------
  for(int i=0; i<12; i++){                                                                  //цикл вывода подложки и надписи "Azimuthal" и "rotary device"
  switch(i){                                                                                //------------------------------------------------------------
    case 0: tft.setTextColor(TFT_DARKGREY); tft.drawString("l",333,53,1);                   //------------------------------------------------------------
            tft.drawString("C",273,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("l",330,50,1); break;                 //------------------------------------------------------------
    case 1: tft.setTextColor(TFT_DARKGREY); tft.drawString("a",310,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("a",307,50,1); break;                 //------------------------------------------------------------
    case 2: tft.setTextColor(TFT_DARKGREY); tft.drawString("h",283,53,1);                   //------------------------------------------------------------
            tft.drawString("T",240,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("h",280,50,1); break;                 //------------------------------------------------------------
    case 3: tft.setTextColor(TFT_DARKGREY); tft.drawString("t",268,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("t",265,50,1); break;                 //------------------------------------------------------------
    case 4: tft.setTextColor(TFT_DARKGREY); tft.drawString("u",241,53,1);                   //------------------------------------------------------------
            tft.drawString("I",222,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("u",238,50,1); break;                 //------------------------------------------------------------
    case 5: tft.setTextColor(TFT_DARKGREY); tft.drawString("m",203,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("m",200,50,1); break;                 //------------------------------------------------------------
    case 6: tft.setTextColor(TFT_DARKGREY); tft.drawString("i",187,53,1);                   //------------------------------------------------------------
            tft.drawString("0",200,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("i",184,50,1); break;                 //------------------------------------------------------------
    case 7: tft.setTextColor(TFT_DARKGREY); tft.drawString("z",166,53,1);                   //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("z",163,50,1); break;                 //------------------------------------------------------------
    case 8: tft.setTextColor(TFT_DARKGREY); tft.drawString("A",133,53,1);                   //------------------------------------------------------------
            tft.drawString("D",160,225,1);                                                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("A",130,50,1); break;}                //------------------------------------------------------------
  switch(i){                                                                                //------------------------------------------------------------
    case 0: if (select==0){music=music13;} if (select==1){music=music44;}                   //взависимости от выбранного рингтона включаем тон соответствующей высоты
            tft.setTextColor(TFT_DARKGREY); tft.drawString("e",342,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("e",339,100,1); break;                //------------------------------------------------------------
    case 1: if (select==0){music=music14;} if (select==1){music=music45;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("c",324,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("c",321,100,1); break;                //------------------------------------------------------------
    case 2: if (select==0){music=music15;} if (select==1){music=music46;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("i",312,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("i",309,100,1); break;                //------------------------------------------------------------
    case 3: if (select==0){music=music16;} if (select==1){music=music47;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("v",290,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("v",287,100,1); break;                //------------------------------------------------------------
    case 4: if (select==0){music=music17;} if (select==1){music=music48;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("e",272,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("e",269,100,1); break;                //------------------------------------------------------------
    case 5: if (select==0){music=music18;} if (select==1){music=music49;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("d",248,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("d",245,100,1); break;                //------------------------------------------------------------
    case 6: if (select==0){music=music19;} if (select==1){music=music50;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("y",215,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("y",212,100,1); break;                //------------------------------------------------------------
    case 7: if (select==0){music=music20;} if (select==1){music=music51;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("r",195,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("r",192,100,1); break;                //------------------------------------------------------------
    case 8: if (select==0){music=music21;} if (select==1){music=music52;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("a",172,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("a",169,100,1); break;                //------------------------------------------------------------
    case 9: if (select==0){music=music22;} if (select==1){music=music53;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("t",156,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("t",153,100,1); break;                //------------------------------------------------------------
    case 10:if (select==0){music=music23;} if (select==1){music=music54;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("o",133,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("o",130,100,1); break;                //------------------------------------------------------------
    case 11:if (select==0){music=music24;} if (select==1){music=music55;}                   //------------------------------------------------------------
            tft.setTextColor(TFT_DARKGREY); tft.drawString("r",113,103,1);                  //------------------------------------------------------------
            tft.setTextColor(TFT_RED); tft.drawString("r",110,100,1); break;}               //------------------------------------------------------------
  if (TONE!=0){tone4.tone(music);} delay(del); tone4.noTone();}                             //если разрешен бипер выводим надписи со звуком слева направо с задержкой "del"
    tft.fillRect(130,47,220,45,TFT_GREY40);                                                 //затираем предыдущее изображение
    tft.fillRect(105,97,260,48,TFT_GREY40);                                                 //-------------------------------
    tft.fillRect(155,220,160,43,TFT_GREY40);                                                //-------------------------------
  for (int i=0; i<7; i++){                                                                  //включаем цикл вывода надписей заставки
  switch(i){                                                                                //функция вывода подложки и надписи "Azimuthal"
    case 0: tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("u",253,53,1);             //------------------------------------------------------------
    tft.drawString("I",222,225,1);                                                          //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("u",250,50,1); break;                   //------------------------------------------------------------
    case 1: tft.setTextColor(TFT_DARKGREY); tft.drawString("m",253-i*50,53,1);              //------------------------------------------------------------
    tft.drawString("t",253+i*15,53,1);                                                      //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawString("m",250-i*50,50,1);                           //------------------------------------------------------------
    tft.drawString("t",250+i*15,50,1); break;                                               //------------------------------------------------------------
    case 2: tft.setTextColor(TFT_DARKGREY); tft.drawString("i",253-i*33,53,1);              //------------------------------------------------------------
    tft.drawString("h",253+i*15,53,1);                                                      //------------------------------------------------------------
    tft.drawString("0",200,225,1); tft.drawString("T",240,225,1);                           //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawString("i",250-i*33,50,1);                           //------------------------------------------------------------
    tft.drawString("h",250+i*15,50,1); break;                                               //------------------------------------------------------------
    case 3: tft.setTextColor(TFT_DARKGREY); tft.drawString("z",253-i*29,53,1);              //------------------------------------------------------------
    tft.drawString("a",253+i*19,53,1);                                                      //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawString("z",250-i*29,50,1);                           //------------------------------------------------------------
    tft.drawString("a",250+i*19,50,1); break;                                               //------------------------------------------------------------
    case 4: tft.setTextColor(TFT_DARKGREY); tft.drawString("A ",253-i*30,53,1);             //------------------------------------------------------------
    tft.drawString("l",253+i*20,53,1);                                                      //------------------------------------------------------------
    tft.drawString("D",160,225,1); tft.drawString("C",273,225,1);                           //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawString("A ",250-i*30,50,1);                          //------------------------------------------------------------
    tft.drawString("l",250+i*20,50,1); break;}                                              //------------------------------------------------------------
  switch(i){                                                                                //функция вывода подложки и надписи "rotary device"
    case 0: if (select==0){music=music25;} if (select==1){music=music56;}                   //взависимости от выбранного рингтона включаем тон соответствующей высоты
    tft.drawCentreString(" ",243,103,1); tft.drawCentreString(" ",240,100,1); break;        //------------------------------------------------------------
    case 1: if (select==0){music=music26;} if (select==1){music=music57;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("y",243-i*18,103,1);               //------------------------------------------------------------
    tft.drawCentreString("d",243+i*18,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("y",240-i*18,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("d",240+i*18,100,1); break;                                        //------------------------------------------------------------
    case 2: if (select==0){music=music27;} if (select==1){music=music58;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("r",243-i*19,103,1);               //------------------------------------------------------------
    tft.drawCentreString("e",243+i*19,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("r",240-i*19,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("e",240+i*19,100,1); break;                                        //------------------------------------------------------------
    case 3: if (select==0){music=music28;} if (select==1){music=music59;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("a",243-i*20,103,1);               //------------------------------------------------------------
    tft.drawCentreString("v",243+i*19,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("a",240-i*20,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("v",240+i*19,100,1); break;                                        //------------------------------------------------------------
    case 4: if (select==0){music=music29;} if (select==1){music=music60;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("t",243-i*20,103,1);               //------------------------------------------------------------
    tft.drawCentreString("i",243+i*19,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("t",240-i*20,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("i",240+i*19,100,1); break;                                        //------------------------------------------------------------
    case 5: if (select==0){music=music30;} if (select==1){music=music61;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("o",243-i*20,103,1);               //------------------------------------------------------------
    tft.drawCentreString("c",243+i*18,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("o",240-i*20,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("c",240+i*18,100,1); break;                                        //------------------------------------------------------------
    case 6: if (select==0){music=music31;} if (select==1){music=music62;}                   //------------------------------------------------------------
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("r",243-i*20,103,1);               //------------------------------------------------------------
    tft.drawCentreString("e",243+i*18,103,1);                                               //------------------------------------------------------------
    tft.setTextColor(TFT_RED); tft.drawCentreString("r",240-i*20,100,1);                    //------------------------------------------------------------
    tft.drawCentreString("e",240+i*18,100,1); break;}                                       //------------------------------------------------------------
  if (TONE!=0){tone4.tone(music);} delay(del); tone4.noTone();}                             //если разрешен бипер выводим надписи со звуком от центра с задержкой "del"
    delay(1000);                                                                            //задержка 1с
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI24);                                                                //иначе выбираем шрифт 
    Wire.requestFrom(104,2);                                                                //получаем данные с адреса 104 I2C
  if (sensor!=pencoder){auto_correction();}                                                 //если при загрузке программы "sensor" и "encoder" не равны уходим в подпрограмму калибровки
  if (Wire.available()){nomodule=0;}                                                        //если линия I2C отвечает "nomodule" выставляем в 0
  else {nomodule=1;                                                                         //если линия I2C не отвечает "nomodule" выставляем в 1
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("DS3231 module",243,103,1);          //выводим подложку надписи "Модуль DS3231"
    tft.setTextColor(TFT_RED); tft.drawCentreString("DS3231 module",240,100,1);             //выводим надпись "DS3231 module"
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("not connected",243,173,1);          //выводим подложку надписи "не подключен"
    tft.setTextColor(TFT_RED); tft.drawCentreString("not connected",240,170,1);             //выводим надпись "not connected"
    delay(1000);}                                                                           //задержка 2с
    encoder.timeRight=0; encoder.timeLeft=0;                                                //обнуляем входа энкодера чтобы избежать ошибки при загрузке программы
    preparing_the_screen();}                                                                //вызываем подпрограмму подготовки экрана
void loop(){//====================================================== Основной цикл ==================================================================
    tft.setTextPadding(0);                                                                  //выключаем обновление подложки шрифта
  if (nomodule==0){                                                                         //если модуль часов подключен
    tmElements_t tm;                                                                        //переменная установки даты и времени
    RTC.read(tm);                                                                           //переменная чтения даты и времени
    int hh=tm.Hour;                                                                         //выводим часы
    int mm=tm.Minute;                                                                       //выводим минуты
    int ss=tm.Second;                                                                       //выводим секунды
    int da=tm.Day;                                                                          //выводим число
    int mo=tm.Month;                                                                        //выводим месяц
    int dy=tm.Wday;                                                                         //выводим день недели
    thermometer();                                                                          //вызываем подпрограмму измерения температуры
  if (TEMP1!=temp3231){flagtemp=false; SetStep=1;}                                          //если значение температуры поменялось выставляем "flagtemp" в false
  if ((hhalarm==tm.Hour)&&(mmalarm==tm.Minute)&&(ssalarm==tm.Second)&&                      //если установленные для будильника значения часов, минут и секунд совпадают с текущими
  (alarmonoff==1)&&(singlealarm==0)){                                                       //и будильник разрешен
    singlealarm++;                                                                          //включаем "singlealarm" счётчиком для однократного звучания будильника
  if (select==0){elis(); alarmonoff=0; EEPROM.update(194,alarmonoff);                       //если "select==0" однократно звучит рингтон "К Элизе"
    tft.fillRect(241,23,69,25,TFT_DARKCYAN); tft.fillRect(281,53,23,26,TFT_DARKCYAN);}      //затираем показания и символ будильника
  if (select==1){polones(); alarmonoff=0; EEPROM.update(194,alarmonoff);                    //если "select==1" однократно звучит рингтон "Полонез Огинского"
    tft.fillRect(243,25,62,20,TFT_DARKCYAN); tft.fillRect(281,53,23,26,TFT_DARKCYAN);}}     //затираем показания и символ будильника
  if (Clock==1){tft.setTextColor(bordercolor,TFT_DARKCYAN); tft.setFreeFont(FSBI12);        //если "Clock" разрешаем вывод часов
    int XPOS=25;                                                                            //начальная координата по х
    int Ypos=272;                                                                           //начальная координата по y
    int Xmin=0;                                                                             //координата по x для вывода минут
    int Xsecs=265;                                                                          //координата по x для вывода секунд
  if (hh<10) XPOS+=tft.drawChar('0',XPOS,Ypos,4);                                           //если показания часов меньше 10 дорисовываем незначащий ноль
    XPOS+=tft.drawNumber(hh,XPOS,Ypos,4);                                                   //выводим значение часов
    Xmin=XPOS;                                                                              //приравниваем координату x вывода секунд к начальной координате по x
    XPOS+=tft.drawChar(':',Xmin,Ypos,4);                                                    //рисуем минутное двоеточие
  if (mm<10) XPOS+=tft.drawChar('0',XPOS,Ypos,4);                                           //если показания минут меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(mm,XPOS,Ypos,4);                                                         //выводим значение минут
    Xsecs+=tft.drawChar(':',Xsecs,Ypos,4);                                                  //рисуем секундное двоеточие
  if (ss<10) Xsecs+=tft.drawChar('0',Xsecs,Ypos,4);                                         //если показания секунд меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(ss,Xsecs,Ypos,4);                                                        //выводим значение секунд
  if (da<10){tft.drawChar('0',25,248,4); tft.drawNumber(da,39,248,4);}                      //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,25,248,4);                                                         //выводим значение даты
  if (mo<10){tft.drawChar('0',272,248,4); tft.drawNumber(mo,287,248,4);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,272,248,4);                                                        //выводим значение месяца
  if (alarmonoff==0){                                                                       //если будильник выключен то выводим дни недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawString("Mon",260,30,1); break;                                          //выводим понедельник
    case 2: tft.drawString("Tue",265,30,1); break;                                          //выводим вторник
    case 3: tft.drawString("Wed",260,30,1); break;                                          //выводим среда
    case 4: tft.drawString("Thu",260,30,1); break;                                          //выводим четверг
    case 5: tft.drawString("Fri",265,30,1); break;                                          //выводим пятница
    case 6: tft.drawString("Sat",265,30,1); break;                                          //выводим суббота
    case 7: tft.drawString("Sun",260,30,1); break;}}}}                                      //выводим воскресенье
    char buf[4]; byte len=3;                                                                //формируем буфер для вывода символьного массива
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (nomodule==0){                                                                         //если "nomodule==0"(модуль часов подключен) начинаем отсчёт времени
  if (millis()-ClockMillis>=1){ClockMillis=millis(); valClock++;}                           //формируем задержку до вызова часов
  if (valClock>=ClockTime){valClock=0; beep(); lock=1; realtime();}}                        //как только значение valClock становится равным ClockTime вызываем подпрограмму часов
  if (Timer==1){tft.setFreeFont(FSBI12); tft.setTextColor(TFT_GREEN);                       //если "Timer==1" подключаем внешний шрифт FSBI12 и выбираем цвет текста
  if (singleStart==0){singleStart++; tft.fillRect(368,248,60,24,TFT_DARKCYAN);              //затираем вывод надписи "Stop"
    tft.drawCentreString("Wait",397,251,1);                                                 //выводим надпись "Wait"
    mmt=0; sst=0;tft.setTextColor(TFT_GREEN,TFT_DARKCYAN);}                                 //обнуляем таймер и выбираем цвет для вывода его начального значения
  if ((start==2)&&(singlePause==1)){singlePause=0; tft.fillRect(368,248,60,24,TFT_DARKCYAN);//затираем вывод надписи "Start"
    tft.drawCentreString("Pause",397,251,1);}                                               //выводим надпись "Pause"
  if ((start==1)&&(singlePause==0)){singlePause++; tft.fillRect(368,248,60,24,TFT_DARKCYAN);//затираем вывод надписи "Pause"
    tft.setTextColor(TFT_RED); tft.drawCentreString("Start",397,251,1);}                    //выводим надпись "Start"
  if (start==1){                                                                            //как только сохранится в память положение красной стрелки запускаем счёт времени
  if (targetTime<millis()){                                                                 //включаем внутренний таймер
    targetTime=millis()+t; sst++;}                                                          //добавляем секунду
  if (sst==60){sst=0; mmt++;                                                                //после 60 секунд обнуляем показания и добавляем  минуту
  if (mmt>1){mmt=0;}}}}                                                                     //после 2 минут обнуляем показания
    int XPOSt=366;                                                                          //начальная координата по х
    int Ypost=272;                                                                          //начальная координата по y
    int Xsecst=0;                                                                           //координата по x для вывода секунд
  if (start==1){tft.setTextColor(TFT_RED,TFT_DARKCYAN);}                                    //выставляем выбранный цвет таймера
  if (start==2){tft.setTextColor(TFT_GREEN);}                                               //---------------------------------
  if (Timer==0){tft.setTextColor(TFT_GREEN);}                                               //---------------------------------
  if (mmt<10) XPOSt+=tft.drawChar('0',XPOSt,Ypost,4);                                       //если показания минут меньше 10 дорисовываем незначащий ноль
    XPOSt+=tft.drawNumber(mmt,XPOSt,Ypost,4);                                               //выводим значение минут
    Xsecst=XPOSt;                                                                           //приравниваем координату x вывода секунд к начальной координате по x
    XPOSt+=tft.drawChar(':',Xsecst,Ypost,4);                                                //рисуем секундное двоеточие
  if (sst<10) XPOSt+=tft.drawChar('0',XPOSt,Ypost,4);                                       //если показания секунд меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(sst,XPOSt,Ypost,4);                                                      //выводим значение секунд
  if (Timer==0){                                                                            //если "Timer==0"
  if (singleStop==0){singleStop++; tft.fillRect(368,248,60,24,TFT_DARKCYAN);                //затираем вывод надписи "Start"
    tft.setFreeFont(FSBI12); tft.drawCentreString("Stop",397,251,1);}}                      //выводим надпись "Stop"
  if (sensor!=pencoder){Timer=1;                                                            //если установленное значение и положение антенны не совпадают выставляем "Timer" в 1
  if (butt1.isSingle()){start++; beep(); if (start>2){start=1;}}}                           //первым кликом включаем движение антенны "Start", вторым "Pause" и так ро кольцу
  if (sensor==pencoder){                                                                    //при остановленной антенне
  if (butt1.isSingle()){beep(); valClock=0; valNav=0; NPosition=0;                          //одинарным кликом подготавливаем счётчики
    menu_navigation();}                                                                     //и входим в режим навигаци по меню
  if (butt1.isDouble()){beep(); valClock=0; if (nomodule==0){lock=1; flagtemp=false;        //двойным кликом вызываем часы если модуль подключен
    realtime();}                                                                            
  else {for(int i=0; i<2; i++){                                                             //а если отсутствует включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI24);                                                                //иначе выбираем шрифт 
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("Need to connect",243,103,1);        //выводим подложку надписи "Необходимо подключить"
    tft.setTextColor(TFT_RED); tft.drawCentreString("Need to connect",240,100,1);           //выводим надпись "Need to connect"
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("DS3231 module",243,173,1);          //выводим подложку надписи "модуль DS3231"
    tft.setTextColor(TFT_RED); tft.drawCentreString("DS3231 module",240,170,1);             //выводим надпись "DS3231 module"
    delay(2000); SetStep=1; preparing_the_screen();}}                                       //задержка 2с
  if (butt1.isTriple()){beep(); valClock=0; memory_reading();}}                             //тройным кликом входим в режим чтения из памяти
  if ((encoder.timeRight!=0)&&(pencoder<number)){pencoder++; beep();                        //включаем счётчик энкодера вправо, выше установленного значения энкодер не работает
    flag_Ememory=1; flag_SEmemory=1; flag_stop++; SetStep=1; valClock=0;                    //устанавливаем "flag_Ememory" и "flag_SEmemory" в 1, "flag_stop" включаем как счётчик
    encoder.timeRight=0;}                                                                   //обнуляем время/признак вращения вправо
  if ((encoder.timeLeft!=0)&&(pencoder!=0)){pencoder--; beep();                             //включаем счётчик вращения энкодера влево, меньше ноля энкодер не работает
    flag_Ememory=1; flag_SEmemory=1; flag_stop++; SetStep=1; valClock=0;                    //устанавливаем "flag_Ememory" и "flag_SEmemory" в 1, "flag_stop" включаем как счётчик
    encoder.timeLeft=0;}                                                                    //обнуляем время/признак вращения влево
  if (pencoder!=sensor){flag_encoder=1; Set_Step=1;}                                        //если значения энкодера и датчика не совпадают выставляем "flag_encoder" в 1
  if ((start==1)&&(singleMem==0)){singleMem++;                                              //после старта антенны однократно записываем в память значение нового азимута
    Pencoder=pencoder; beepMem=1;                                                           //включаем звуковое подтверждение записи в EEPROM частотой 700Гц
    EEPROM.update(5,highByte(Pencoder)); EEPROM.update(6,lowByte(Pencoder));}               //значение энкодера записываем в EEPROM
  if ((flag_encoder==1)&&(flag_Position==0)){                                               //если "flag_encoder==1" и "flag_Position==0" разрешаем вывод значения установки азимута
    tft.setTextColor(TFT_RED,TFT_DARKCYAN);                                                 //выбираем цвет надписи и подложки
  if (number==360){dtostrf(pencoder,len,0,buf); buf[len]='.'; buf[len+1]=0;                 //если количество импульсов 360 конвертируем символьный массив вывода данных
    tft.setTextPadding(102); tft.drawCentreString(buf,400,174,7);}                          //выводим значение установки азимута с символом "°" в конце
  if (number==72){dtostrf(pencoder*5,len,0,buf); buf[len]='.'; buf[len+1]=0;                //если количество импульсов 72 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,174,7);}                          //-------------------------------------------------------------
  if (number==36){dtostrf(pencoder*10,len,0,buf); buf[len]='.'; buf[len+1]=0;               //если количество импульсов 36 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,174,7);}                          //-------------------------------------------------------------
  if (number==24){dtostrf(pencoder*15,len,0,buf); buf[len]='.'; buf[len+1]=0;               //если количество импульсов 24 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,174,7);}                          //-------------------------------------------------------------
  if (number==16){dtostrf(pencoder*22.5,len,0,buf); buf[len]='.'; buf[len+1]=0;             //если количество импульсов 16 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,174,7);}}                         //-------------------------------------------------------------
    boolean GerconIsUp=digitalRead(Gercon);                                                 //читаем состояние порта "Gercon"
  if (GerconWasUp&&!GerconIsUp){delay(10);                                                  //если кнопка нажата делаем задержку для антидребезга
    GerconIsUp=digitalRead(Gercon);                                                         //снова читаем состояние порта
  if ((!GerconIsUp)&&(start==1)){                                                           //если состояние кнопки отличается от исходного
  if (sensor<pencoder){sensor++; beep(); SetStep=1; flag_SEmemory=1; valClock=0;}           //если значение энкодера больше датчика включаем движение антенны по часовой стрелке
  if (sensor>pencoder){sensor--; beep(); SetStep=1; flag_SEmemory=1; valClock=0;}}}         //если значение энкодера меньше датчика включаем движение антенны против часовой стрелки
    GerconWasUp=GerconIsUp;                                                                 //приравниваем переменные состояния кнопки
  if (sensor>pencoder){                                                                     //если значение датчика больше энкодера высокий уровень на выв.12
  if (start==1){digitalWrite(Right,LOW); digitalWrite(Left,HIGH);}                          //после нажатия на кнопку начинается движение антенны по часовой стрелке
  if (start==2){digitalWrite(Right,LOW); digitalWrite(Left,LOW);}}                          //повторное нажатие-остановка
  if (sensor<pencoder){                                                                     //если значение датчика меньше энкодера высокий уровень на выв.13
  if (start==1){digitalWrite(Right,HIGH); digitalWrite(Left,LOW);}                          //после нажатия на кнопку начинается движение антенны против часовой стрелки
  if (start==2){digitalWrite(Right,LOW); digitalWrite(Left,LOW);}}                          //повторное нажатие-остановка
  if (sensor==pencoder){digitalWrite(Right,LOW);digitalWrite(Left,LOW);                     //если значение датчика и энкодера совпадают на выв.13 и 12 выводим низкие уровни
  if (flag_SEmemory==1){Sensor=sensor; Pencoder=pencoder; beepMem=1;                        //если "flag_SEmemory==1" включаем звуковое подтверждение остановки антенны
    EEPROM.update(0,highByte(Sensor)); EEPROM.update(1,lowByte(Sensor));                    //запоминаем состояние датчика
    EEPROM.update(5,highByte(Pencoder)); EEPROM.update(6,lowByte(Pencoder));                //и значение энкодера в EEPROM
    Timer=0; singleStart=0; singleStop=0; singlePause=0; start=0; flagtemp=false;}          //запрещаем счёт таймера
    Set_Step=2; flag_encoder=0; flag_Position=0; singleMem=0; flag_SEmemory=0;}             //разрешаем вывод надписи "Stop", сбрасываем флаги в 0
  if (SetStep==1){                                                                          //если "SetStep==1" разрешаем выбор надписей "Setting/Temp"
    edeg=pencoder*step;                                                                     //рисуем стрелку с выбранным шагом
    ex=cos((edeg-90)*0.0174532925);                                                         //расчёт крайних координат стрелки
    ey=sin((edeg-90)*0.0174532925);                                                         //--------------------------------
    tft.drawLine(oex,oey,xpos,161,TFT_GREY100);                                             //затираем предыдущую стрелку
    oex=ex*90+xpos;                                                                         //расчёт начальных координат стрелки
    oey=ey*90+161;                                                                          //----------------------------------
    tft.drawLine(oex,oey,xpos,161,TFT_RED);                                                 //рисуем новую стрелку красного цвета
  if ((stp>1)&&(flag_SEmemory==0)){                                                         //если выбран датчик от 10° до 22,5° и после остановки антенны разрешаем рисовать точку
    edeg=pencoder*step;                                                                     //рисуем точку с выбранным шагом
    sx=cos((edeg-90)*0.0174532925);                                                         //расчёт координат точек
    sy=sin((edeg-90)*0.0174532925);                                                         //----------------------
    tft.fillCircle(x1,yy1,3,TFT_WHITE);                                                     //затираем предыдущую точку
    x1=sx*100+xpos;                                                                         //-------------------------
    yy1=sy*100+160;                                                                         //-------------------------
    tft.fillCircle(x1,yy1,3,TFT_RED);}                                                      //рисуем новую точку красного цвета
  if ((stp>1)&&(singlePoint==0)){singlePoint++;                                             //если выбран датчик больше 1° и "singlePoint=0" рисуем точку по выходу из предустановок
    edeg=sensor*step;                                                                       //рисуем точку с выбранным шагом
    sx=cos((edeg-90)*0.0174532925);                                                         //расчёт координат точек
    sy=sin((edeg-90)*0.0174532925);                                                         //----------------------
    tft.fillCircle(x1,yy1,3,TFT_WHITE);                                                     //затираем предыдущую точку
    x1=sx*100+xpos;                                                                         //-------------------------
    yy1=sy*100+160;                                                                         //-------------------------
    tft.fillCircle(x1,yy1,3,TFT_RED);}                                                      //рисуем новую точку красного цвета
  switch (Set_Step){                                                                        //функция переключения Setting/Step
    case 1: 
  if ((flag_stop==1)&&(flag_Position==0)){                                                  //если "flag_stop==1" и "flag_Position==0"
    tft.fillRect(335,138,120,85,TFT_DARKCYAN);                                              //затираем место вывода значения "TEMP"
    tft.setFreeFont(FSBI18); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI18 и выбираем цвет текста
    tft.drawCentreString("Setting",396,140,1);}                                             //выводим надпись "Setting"
  if (flag_Position==1){flag_Position++; tft.setFreeFont(FSBI18);                           //если "flag_Position==1" включаем его счётчиком и подключаем внешний шрифт FSBI18
    tft.fillRoundRect(325,128,141,105,8,TFT_YELLOW);                                        //затираем место вывода "Setting"
    tft.setTextColor(TFT_RED);                                                              //выбираем цвет выводимых предустановок
  if (number==360){                                                                         //если выбран датчик на 360 импульсов
  if (pencoder==can){tft.drawCentreString("Canada",396,140,1);}                             //выводим надпись "Canada" вместо надписи "Setting"
  if (pencoder==nam){tft.setFreeFont(FSBI12);                                               //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Northern",396,136,1);                                             //выводим надпись "Northern" ---------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==lam){tft.setFreeFont(FSBI12);                                               //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Latin",396,136,1);                                                //выводим надпись "Latin" ------------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==eur){tft.drawCentreString("Europe",396,140,1);}                             //выводим надпись "Europe" -----------------------
  if (pencoder==jap){tft.drawCentreString("Japan",396,140,1);}                              //выводим надпись "Japan" ------------------------
  if (pencoder==ind){tft.drawCentreString("India",396,140,1);}                              //выводим надпись "India" ------------------------
  if (pencoder==aus){tft.drawCentreString("Australia",396,140,1);}                          //выводим надпись "Australia" --------------------
  if (pencoder==afr){tft.drawCentreString("Africa",396,140,1);}                             //выводим надпись "Africa" -----------------------
  switch(pencoder){
    case  0 ... 9:  tft.drawNumber(pencoder,383,183,6);                                     //выводим единицы азимута
    tft.fillCircle(412,187,3,TFT_RED); break;                                               //с символом "°" в конце
    case 10 ... 99: tft.drawNumber(pencoder,370,183,6);                                     //выводим десятки азимута
    tft.fillCircle(430,187,3,TFT_RED); break;                                               //-----------------------
    case 100 ... 360: tft.drawNumber(pencoder,355,183,6);                                   //выводим сотни азимута
    tft.fillCircle(442,187,3,TFT_RED); break;}}                                             //---------------------
  if (number==72){                                                                          //если выбран датчик на 72 импульса
  if (pencoder==can72){tft.drawCentreString("Canada",396,140,1);}                           //выводим надпись "Canada" вместо надписи "Setting"
  if (pencoder==nam72){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Northern",396,136,1);                                             //выводим надпись "Northern" ---------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==lam72){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Latin",396,136,1);                                                //выводим надпись "Latin" ------------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==eur72){tft.drawCentreString("Europe",396,140,1);}                           //выводим надпись "Europe" -----------------------
  if (pencoder==jap72){tft.drawCentreString("Japan",396,140,1);}                            //выводим надпись "Japan" ------------------------
  if (pencoder==ind72){tft.drawCentreString("India",396,140,1);}                            //выводим надпись "India" ------------------------
  if (pencoder==aus72){tft.drawCentreString("Australia",396,140,1);}                        //выводим надпись "Australia" --------------------
  if (pencoder==afr72){tft.drawCentreString("Africa",396,140,1);}                           //выводим надпись "Africa" -----------------------
  switch(pencoder){
    case  1 ... 19:  tft.drawNumber(pencoder*5,370,183,6);                                  //выводим десятки азимута
    tft.fillCircle(430,187,3,TFT_RED); break;                                               //с символом "°" в конце
    case 20 ... 72: tft.drawNumber(pencoder*5,355,183,6);                                   //выводим сотни азимута
    tft.fillCircle(442,187,3,TFT_RED); break;                                               //-----------------------
    default: tft.drawNumber(pencoder,383,183,6);                                            //выводим азимут равный 0°
    tft.fillCircle(412,187,3,TFT_RED); break;}}                                             //-----------------------  
  if (number==36){                                                                          //если выбран датчик на 36 импульсов
  if (pencoder==can36){tft.drawCentreString("Canada",396,140,1);}                           //выводим надпись "Canada" вместо надписи "Setting"
  if (pencoder==nam36){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Northern",396,136,1);                                             //выводим надпись "Northern" ---------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==lam36){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Latin",396,136,1);                                                //выводим надпись "Latin" ------------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==eur36){tft.drawCentreString("Europe",396,140,1);}                           //выводим надпись "Europe" -----------------------
  if (pencoder==jap36){tft.drawCentreString("Japan",396,140,1);}                            //выводим надпись "Japan" ------------------------
  if (pencoder==ind36){tft.drawCentreString("India",396,140,1);}                            //выводим надпись "India" ------------------------
  if (pencoder==aus36){tft.drawCentreString("Australia",396,140,1);}                        //выводим надпись "Australia" --------------------
  if (pencoder==afr36){tft.drawCentreString("Africa",396,140,1);}                           //выводим надпись "Africa" -----------------------
  switch(pencoder){
    case  1 ... 9:  tft.drawNumber(pencoder*10,370,183,6);                                  //выводим десятки азимута
    tft.fillCircle(430,187,3,TFT_RED); break;                                               //с символом "°" в конце
    case 10 ... 36: tft.drawNumber(pencoder*10,355,183,6);                                  //выводим сотни азимута
    tft.fillCircle(442,187,3,TFT_RED); break;                                               //-----------------------
    default: tft.drawNumber(pencoder,383,183,6);                                            //выводим азимут равный 0°
    tft.fillCircle(412,187,3,TFT_RED); break;}}                                             //-----------------------
  if (number==24){                                                                          //если выбран датчик на 24 импульса
  if (pencoder==can24){tft.drawCentreString("Canada",396,140,1);}                           //выводим надпись "Canada" вместо надписи "Setting"
  if (pencoder==nam24){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Northern",396,136,1);                                             //выводим надпись "Northern" ---------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==lam24){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Latin",396,136,1);                                                //выводим надпись "Latin" ------------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==eur24){tft.drawCentreString("Europe",396,140,1);}                           //выводим надпись "Europe" -----------------------
  if (pencoder==jap24){tft.drawCentreString("Japan",396,140,1);}                            //выводим надпись "Japan" ------------------------
  if (pencoder==ind24){tft.drawCentreString("India",396,140,1);}                            //выводим надпись "India" ------------------------
  if (pencoder==aus24){tft.drawCentreString("Australia",396,140,1);}                        //выводим надпись "Australia" --------------------
  if (pencoder==afr24){tft.drawCentreString("Africa",396,140,1);}                           //выводим надпись "Africa" -----------------------
  switch(pencoder){
    case 1 ... 6:  tft.drawNumber(pencoder*15,370,183,6);                                   //выводим десятки азимута
    tft.fillCircle(430,187,3,TFT_RED); break;                                               //с символом "°" в конце
    case 7 ... 24: tft.drawNumber(pencoder*15,355,183,6);                                   //выводим сотни азимута
    tft.fillCircle(442,187,3,TFT_RED); break;                                               //-----------------------
    default: tft.drawNumber(pencoder,383,183,6);                                            //выводим азимут равный 0°
    tft.fillCircle(412,187,3,TFT_RED); break;}}                                             //-----------------------
  if (number==16){                                                                          //если выбран датчик на 16 импульсов
  if (pencoder==can16){tft.drawCentreString("Canada",396,140,1);}                           //выводим надпись "Canada" вместо надписи "Setting"
  if (pencoder==nam16){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Northern",396,136,1);                                             //выводим надпись "Northern" ---------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==lam16){tft.setFreeFont(FSBI12);                                             //подключаем внешний шрифт FSBI12
    tft.drawCentreString("Latin",396,136,1);                                                //выводим надпись "Latin" ------------------------
    tft.drawCentreString("America",396,155,1);}                                             //выводим надпись "America" ----------------------
  if (pencoder==eur16){tft.drawCentreString("Europe",396,140,1);}                           //выводим надпись "Europe" -----------------------
  if (pencoder==jap16){tft.drawCentreString("Japan",396,140,1);}                            //выводим надпись "Japan" ------------------------
  if (pencoder==ind16){tft.drawCentreString("India",396,140,1);}                            //выводим надпись "India" ------------------------
  if (pencoder==aus16){tft.drawCentreString("Australia",396,140,1);}                        //выводим надпись "Australia" --------------------
  if (pencoder==afr16){tft.drawCentreString("Africa",396,140,1);}                           //выводим надпись "Africa" -----------------------
  switch(pencoder){
    case 1 ... 4:  tft.drawNumber(pencoder*22.5,370,183,6);                                 //выводим десятки азимута
    tft.fillCircle(430,187,3,TFT_RED); break;                                               //с символом "°" в конце
    case 5 ... 16: tft.drawNumber(pencoder*22.5,355,183,6);                                 //выводим сотни азимута
    tft.fillCircle(442,187,3,TFT_RED); break;                                               //-----------------------
    default: tft.drawNumber(pencoder,383,183,6);                                            //выводим азимут равный 0°
    tft.fillCircle(412,187,3,TFT_RED); break;}}} break;                                     //-----------------------
    case 2: flag_stop=0;                                                                    //обнуляем "flag_stop"
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.fillRoundRect(327+i,130+i,137-i*2,101-i*2,5-i,TFT_DARKCYAN);                        //-------------
    tft.drawRoundRect(325+i,128+i,141-i*2,105-i*2,8-i,bordercolor);                         //-------------
    tft.drawRoundRect(329+i,132+i,133-i*2,97-i*2,8-i,bordercolor);}                         //восстанавливаем окантовку для вывода значения "Setting" или "Temp"
    tft.setFreeFont(FSBI18); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI18 и выбираем цвет текста
  if (nomodule==1){                                                                         //если модуль часов не подключен
    tft.drawCentreString("Step",396,140,1);                                                 //выводим надпись "Step"
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста
  if (number==360){tft.drawNumber(step,380,180,6);                                          //если шаг датчика 1° выводим значение шага
    tft.fillCircle(405,184,3,TFT_GREEN);}                                                   //и символ "°" со своими координатами вывода на экран
  if (number==72){tft.drawNumber(step,380,180,6);                                           //если шаг датчика 5° -----------------------------------
    tft.fillCircle(405,184,3,TFT_GREEN);}                                                   //-------------------------------------------------------
  if ((number==36)||(number==24)){tft.drawNumber(step,365,180,6);                           //если шаг датчика 10° или 15° --------------------------
    tft.fillCircle(422,184,3,TFT_GREEN);}                                                   //-------------------------------------------------------
  if (number==16){tft.drawFloat(step,1,350,180,6);                                          //если шаг датчика 22,5° выводим значение шага с одним знаком после запятой
    tft.fillCircle(450,184,3,TFT_GREEN);}}                                                  //-------------------------------------------------------
  if (nomodule==0){                                                                         //если модуль часов подключен
    tft.drawCentreString("Temp",396,140,1);                                                 //выводим надпись "Temp"
  if (!flagtemp){flagtemp=true; TEMP1=temp3231;                                             //приравниваем "TEMP2" к температуре и выставляем "flagtemp" в true
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_GREEN,TFT_DARKCYAN);                      //выбираем шрифт и цвет текста
    char bufT[5]; byte lenT=4; dtostrf(TEMP1,-lenT,1,bufT);                                 //конвертируем символьный массив
    bufT[lenT]='C'; bufT[lenT+1]=0;                                                         //вывода данных температуры
    tft.drawCentreString(bufT,396,185,1);}} break;}                                         //раз в минуту выводим значение температуры с добавлением "С"
    sdeg=sensor*step;                                                                       //рисуем стрелку положения антенны с выбранным шагом
    sx=cos((sdeg-90)*0.0174532925);                                                         //расчёт крайних координат стрелки
    sy=sin((sdeg-90)*0.0174532925);                                                         //--------------------------------
    tft.drawLine(osx,osy,xpos,161,TFT_GREY100);                                             //затираем предыдущую стрелку
    osx=sx*90+xpos;                                                                         //расчёт начальных координат стрелки
    osy=sy*90+161;                                                                          //----------------------------------
    tft.drawLine(osx,osy,xpos,161,TFT_GREEN);                                               //рисуем новую стрелку зелёного цвета
    tft.fillCircle(xpos,161,5,TFT_GREEN);                                                   //рисуем центр стрелки
    SetStep=0;}                                                                             //сбрасываем "SetStep" в 0
    tft.setTextColor(TFT_GREEN,TFT_DARKCYAN);                                               //выбираем цвет надписи и подложки
  if (number==360){dtostrf(sensor,len,0,buf); buf[len]='.'; buf[len+1]=0;                   //если количество импульсов 360 конвертируем символьный массив вывода данных
    tft.setTextPadding(102); tft.drawCentreString(buf,400,61,7);}                           //выводим значение положения антенны с символом "°" в конце
  if (number==72){dtostrf(sensor*5,len,0,buf); buf[len]='.'; buf[len+1]=0;                  //если количество импульсов 72 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,61,7);}                           //-------------------------------------------------------------
  if (number==36){dtostrf(sensor*10,len,0,buf); buf[len]='.'; buf[len+1]=0;                 //если количество импульсов 36 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,61,7);}                           //-------------------------------------------------------------
  if (number==24){dtostrf(sensor*15,len,0,buf); buf[len]='.'; buf[len+1]=0;                 //если количество импульсов 24 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,61,7);}                           //-------------------------------------------------------------
  if (number==16){dtostrf(sensor*22.5,len,0,buf); buf[len]='.'; buf[len+1]=0;               //если количество импульсов 16 --------------------------------
    tft.setTextPadding(102); tft.drawCentreString(buf,400,61,7);}                           //-------------------------------------------------------------
  if (beepCal==1){//******************************************** Звуковая сигнализация **************************************************************
  for(int i=700; i<1200; i++){tone4.tone(i);                                                //если "flag_beepС==1", устанавливаем изменение тональности бипера окончания коррекции
    delay(1);} tone4.noTone(); beepCal=0;}                                                  //формируем длительность изменяемых частот, отключаем бипер и сбрасываем "flag_beepС" в 0
  if (TONE!=0){ symbol_speaker();                                                           //если "beeper==1", выводим на экран символ динамика
  if (beepMem==1){tone4.tone(700);                                                          //если "flag_beeperM==1", устанавливаем тональность бипера записи в память
  if(millis()-beepMillis>=1){beepMillis=millis(); valBeep++;}                               //формируем длительность бипера
  if (valBeep>=TimeBeep){valBeep=0; tone4.noTone(); beepMem=0;}}}                           //по истечении времени "TimeBeep" отключаем бипер и сбрасываем "beepMem" в ноль
}//********************************************************************* Бипер **********************************************************************
void beep(){if (TONE!=0){tone4.tone(TONE*100); delay(50); tone4.noTone();}}                 //если "beeper==1", устанавливаем тональность, длительность и отключаем бипер
void symbol_speaker(){//****************************************** Символ динамика ******************************************************************
    int xsp=35; int ysp=28;                                                                 //начальные координаты
    tft.drawFastVLine(xsp+12,ysp+11,3,TFT_GREEN);                                           //рисуем "звуковые волны"
    tft.drawCircleHelper(xsp+12,ysp+12,4,6,TFT_GREEN);                                      //----------------------
    tft.drawCircleHelper(xsp+12,ysp+12,7,6,TFT_GREEN);                                      //----------------------
    tft.fillRect(xsp,ysp+7,3,10,TFT_GREEN); tft.fillRect(xsp+4,ysp+6,6,12,TFT_GREEN);       //рисуем "магнит" динамика и "диффузор"
    tft.fillTriangle(xsp+4,ysp+6,xsp+10,ysp+6,xsp+10,ysp,TFT_GREEN);                        //----------------
    tft.fillTriangle(xsp+4,ysp+17,xsp+10,ysp+17,xsp+10,ysp+23,TFT_GREEN);}                  //----------------
void symbol_bell(){//*********************************** Символ колокола в основном экране **********************************************************
    x=280; y=55;                                                                            //начальные координаты
    tft.fillCircle(x+11,y,2,TFT_RED);                                                       //рисуем корону
    tft.fillCircle(x+11,y+8,8,TFT_RED);                                                     //рисуем корону
    tft.fillRect(x+3,y+11,17,5,TFT_RED);                                                    //------ талию
    tft.fillTriangle(x,y+18,x+11,y+8,x+23,y+18,TFT_RED);                                    //------ губу
    tft.fillCircle(x+11,y+21,2,TFT_RED);                                                    //------ язык
    tft.fillRect(x+8,y+19,6,2,TFT_DARKCYAN);}                                               //-----------
void symbol_bell_clock(){//********************************** Символ колокола в часах ***************************************************************
    x=70; y=39;                                                                             //начальные координаты
    tft.fillCircle(x+11,y,2,TFT_RED);                                                       //рисуем корону
    tft.fillCircle(x+11,y+8,8,TFT_RED);                                                     //рисуем корону
    tft.fillRect(x+3,y+11,17,5,TFT_RED);                                                    //------ талию
    tft.fillTriangle(x,y+18,x+11,y+8,x+23,y+18,TFT_RED);                                    //------ губу
    tft.fillCircle(x+11,y+21,2,TFT_RED);                                                    //------ язык
    tft.fillRect(x+8,y+19,6,2,TFT_YELLOW);}                                                 //-----------
void symbol_clock(){//********************************************* Символ часов ********************************************************************
    x=75; y=135;                                                                            //начальные координаты
    tft.drawCircle(x,y,31,TFT_RED);                                                         //рисуем циферблат
    tft.drawCircle(x,y,30,TFT_RED);                                                         //----------------
    tft.fillCircle(x,y,29,TFT_YELLOW);                                                      //----------------
    tft.fillCircle(x,y,3,TFT_RED);                                                          //----------------
    tft.drawLine(x,y-2,x,y-27,TFT_RED);                                                     //рисуем стрелки
    tft.drawLine(x+2,y,x+22,y,TFT_RED);}                                                    //--------------
void auto_correction(){//************************************ Автоматическая коррекция **************************************************************
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI24); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18 и выбираем цвет подложки надписи
    tft.drawCentreString("Going to azimuth 0",240,103,1);                                   //выводим подложку надписи "Going to azimuth 0"(Переход на aзимут 0)
    tft.drawString(".",427,97,7);                                                           //выводим символ "°"
    tft.setTextColor(TFT_RED);                                                              //выбираем цвет надписи
    tft.drawCentreString("Going to azimuth 0",237,100,1);                                   //выводим надпись "Going to azimuth 0"
    tft.drawString(".",425,95,7);                                                           //выводим символ "°"
while (digitalRead(Terminal)==HIGH){                                                        //пока на "Terminal" высокий уровень
    digitalWrite(Right,LOW);digitalWrite(Left,HIGH);}                                       //включаем движение антенны к азимуту 0°
    digitalWrite(Right,LOW); digitalWrite(Left,LOW);                                        //как только антенна достигает концевого движение прекращается
    EEPROM.update(0,0);EEPROM.update(1,0);EEPROM.update(5,0);EEPROM.update(6,0);            //сохраняем результат коррекции в EEPROM
    Sensor  =word(EEPROM.read(0),EEPROM.read(1)); sensor=Sensor;                            //читаем положение
    Pencoder=word(EEPROM.read(5),EEPROM.read(6)); pencoder=Pencoder;                        //и установку движения антенны из EEPROM
    beepCal=1; flagtemp=false;}                                                             //включаем звуковое подтверждение окончания коррекции
void preparing_the_screen(){//********************************** Подготовка экрана ******************************************************************
    stp=EEPROM.read(15);                                                                    //читаем содержимое ячейки 15 и загружаем данные о шаге датчика
    ClockTime=EEPROM.read(16); ClockTime=ClockTime*100;                                     //читаем содержимое ячейки 16 и загружаем данные о задержке
    Sensor  =word(EEPROM.read(0),EEPROM.read(1)); sensor=Sensor;                            //читаем положение
    Pencoder=word(EEPROM.read(5),EEPROM.read(6)); pencoder=Pencoder;                        //и установку движения антенны из EEPROM
  switch (stp){                                                                             //оператор выбора шага датчика антенны
    case 1: step=1; number=360; break;                                                      //если "stp=1" датчик имеет шаг 1°(360 импульсов)
    case 2: step=5; number=72; break;                                                       //если "stp=2" датчик имеет шаг 5°(72 импульса)
    case 3: step=10; number=36; break;                                                      //если "stp=3" датчик имеет шаг 10°(36 импульсов)
    case 4: step=15; number=24; break;                                                      //если "stp=4" датчик имеет шаг 15°(24 импульса)
    case 5: step=22.5; number=16; break;}                                                   //если "stp=5" датчик имеет шаг 22,5°(16 импульсов)
    tft.fillRoundRect(6,6,468,308,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.fillRoundRect(16+i,17+i,299-i*2,285-i*2,5-i,TFT_DARKCYAN);                          //-------------
    tft.drawRoundRect(14+i,15+i,303-i*2,289-i*2,8-i,bordercolor);                           //-------------
    tft.drawRoundRect(18+i,19+i,295-i*2,281-i*2,8-i,bordercolor);}                          //рисуем окантовку для компаса
    tft.fillCircle(xpos,160,128,TFT_GREY100);                                               //рисуем внутренний фон компаса
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawCircle(xpos,160,128+i,TFT_WHITE);}                                              //рисуем внутренюю окантовку компаса
  for(int i=0; i<6; i++){                                                                   //включаем цикл
    tft.drawCircle(xpos,160,130+i,bordercolor);}                                            //рисуем внешнюю окантовку компаса
  switch (stp){                                                                             //оператор выбора рисования точек на компасе
    case 1: Step=5; break;                                                                  //если "stp==1" рисуем точки через 5°
    case 2: Step=5; break;                                                                  //если "stp==2" рисуем точки через 5°
    case 3: Step=10; break;                                                                 //если "stp==3" рисуем точки через 10°
    case 4: Step=15; break;                                                                 //если "stp==4" рисуем точки через 15°
    case 5: Step=22.5; break;}                                                              //если "stp==5" рисуем точки через 22.5°
  for (float i=0; i<360; i+=Step){                                                          //рисуем точки с выбранным шагом
    sx=cos((i-90)*0.0174532925);                                                            //------------------------------
    sy=sin((i-90)*0.0174532925);                                                            //------------------------------
    x0=sx*114+xpos;                                                                         //------------------------------
    yy0=sy*114+160;                                                                         //------------------------------
    x1=sx*100+xpos;                                                                         //------------------------------
    yy1=sy*100+160;                                                                         //------------------------------
    tft.fillCircle(x1,yy1,3,TFT_WHITE);}                                                    //------------------------------
  for (int i=0; i<360; i+=15) {                                                             //подписываем точки главного квадранта
    sx=cos((i-90)*0.0174532925);                                                            //------------------------------------
    sy=sin((i-90)*0.0174532925);                                                            //------------------------------------
    x0=sx*102+xpos;                                                                         //------------------------------------
    yy0=sy*102+160-5;                                                                       //------------------------------------
    tft.setFreeFont(FSBI12); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI12 и выбираем цвет текста
  if (i==0)  tft.drawCentreString("N",x0,yy0-17,1);                                         //выводим надпись "N"
  if (i==90) tft.drawCentreString("E",x0+12,yy0,1);                                         //выводим надпись "E"
  if (i==180)tft.drawCentreString("S",x0,yy0+11,1);                                         //выводим надпись "S"
  if (i==270)tft.drawCentreString("W",x0-15,yy0,1);}                                        //выводим надпись "W"
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.fillRoundRect(327+i,17+i,137-i*2,101-i*2,5-i,TFT_DARKCYAN);                         //-------------
    tft.drawRoundRect(325+i,15+i,141-i*2,105-i*2,8-i,bordercolor);                          //-------------
    tft.drawRoundRect(329+i,19+i,133-i*2,97-i*2,8-i,bordercolor);}                          //рисуем окантовку для вывода значения "Position"
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.fillRoundRect(327+i,130+i,137-i*2,101-i*2,5-i,TFT_DARKCYAN);                        //-------------
    tft.drawRoundRect(325+i,128+i,141-i*2,105-i*2,8-i,bordercolor);                         //-------------
    tft.drawRoundRect(329+i,132+i,133-i*2,97-i*2,8-i,bordercolor);}                         //рисуем окантовку для вывода значения "Setting"
    tft.setFreeFont(FSBI18); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI18 и выбираем цвет текста
    tft.drawCentreString("Position",396,26,1);                                              //выводим надпись "Position"
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.fillRoundRect(327+i,243+i,137-i*2,59-i*2,5-i,TFT_DARKCYAN);                         //-------------
    tft.drawRoundRect(325+i,241+i,141-i*2,63-i*2,8-i,bordercolor);                          //-------------
    tft.drawRoundRect(329+i,245+i,133-i*2,55-i*2,8-i,bordercolor);}                         //рисуем окантовку для вывода надписей "Stop/Start"
  if ((alarmonoff==1)&&(nomodule==0)){symbol_bell(); tft.setTextColor(TFT_RED);             //выводим символ будильника
  for(int i=0; i<2; i++){                                                                   //запускаем цикл
    tft.drawRoundRect(241+i,23+i,69-i*2,25-i*2,4-i,TFT_RED);}                               //рисуем наружную окантовку
    tft.fillRoundRect(243,25,65,21,2,TFT_YELLOW);                                           //заливаем её фоном
    int xpos=244;                                                                           //начальная координата по х
    int ypos=25;                                                                            //начальная координата по y
    int xmin=0;                                                                             //координата по x для вывода минут
  if (hhalarm<10) xpos+=tft.drawChar('0',xpos,ypos,4);                                      //если показания часов меньше 10 дорисовываем незначащий ноль
    xpos+=tft.drawNumber(hhalarm,xpos,ypos,4);                                              //выводим значение часов
    xmin=xpos;                                                                              //приравниваем координату x вывода секунд к начальной координате по x
    xpos+=tft.drawChar(':',xmin,ypos,4);                                                    //рисуем минутное двоеточие
  if (mmalarm<10) xpos+=tft.drawChar('0',xpos,ypos,4);                                      //если показания минут меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(mmalarm,xpos,ypos,4);}                                                   //выводим значение минут
    singleStop=0; flag_encoder=1;}                                                          //"flag_encoder" выставляем в 1 для индикации "Setting" после загрузки программы
void menu_navigation(){//************************************** Навигация по меню *******************************************************************
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.fillRoundRect(16,45,448,60,8,TFT_DARKCYAN);                                         //рисуем прямоугольники фона для рамок вывода пунктов меню
    tft.fillRoundRect(16,111,448,60,8,TFT_DARKCYAN);                                        //--------------------------------------------------------
    tft.fillRoundRect(16,177,448,60,8,TFT_DARKCYAN);                                        //--------------------------------------------------------
    tft.drawRoundRect(19,48,442,54,8,bordercolor);                                          //рисуем внутренние рамки вывода пунктов меню
    tft.drawRoundRect(19,114,442,54,8,bordercolor);                                         //--------------------------------------------
    tft.drawRoundRect(19,180,442,54,8,bordercolor);                                         //--------------------------------------------
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRoundRect(15+i,44+i,450-i*2,62-i*2,8-i,bordercolor);                            //рисуем окантовки рамок вывода пунктов меню
    tft.drawRoundRect(15+i,110+i,450-i*2,62-i*2,8-i,bordercolor);                           //------------------------------------------
    tft.drawRoundRect(15+i,176+i,450-i*2,62-i*2,8-i,bordercolor);}                          //------------------------------------------
    tft.setFreeFont(FSBI12); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI12
    tft.drawCentreString("-- MENU  NAVIGATION --",240,17,1);                                //выводим надпись "-- MENU NAVIGATION --"
    tft.setTextColor(TFT_DARKGREY); tft.drawString("AUTOMATIC EXIT AFTER",70,265,1);        //выводим надпись "AUTOMATIC EXIT AFTER"
    tft.drawString("sec",380,265,1);                                                        //выводим надпись "sec"
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста
    tft.drawString("PREINSTALL",25,67,1);                                                   //выводим надпись "PREINSTALL"
    tft.drawString("MENU page 1",25,133,1);                                                 //выводим надпись "MENU page 1"
    tft.drawString("MENU page 2",25,199,1);                                                 //выводим надпись "MENU page 2"
    tft.drawString("Single Click to Login",240,67,1);                                       //выводим надпись "Single Click to Login"
    tft.drawString("Double Click to Login",240,133,1);                                      //выводим надпись "Double Click to Login"
    tft.drawString("Triple Click to Login",240,199,1);                                      //выводим надпись "Triple Click to Login"
while (NPosition==0){                                                                       //находимся в цикле пока "NPosition==0"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isSingle()){beep(); valNav=0; Color=1;}                                         //одинарным кликом "Color" устанавливаем в 1 и сбрасываем счётчик в 0
  if (butt1.isDouble()){beep(); valNav=0; Color=2;}                                         //двойным кликом  "Color" устанавливаем в 2 и сбрасываем счётчик в 0
  if (butt1.isTriple()){beep(); valNav=0; Color=3;}                                         //тройным кликом  "Color" устанавливаем в 3 и сбрасываем счётчик в 0
  if (millis()-NavMillis>=1){NavMillis=millis(); valNav++; int delay;                       //формируем задержку выхода из навигации по меню без выбора пункта
  switch(valNav){                                                                           //функция перевода значений счётчика в секунды с обратным отсчётом
    case    1: delay=5;  break;                                                             //если значение счётчика равно 1 то отображается 5сек
    case  700: delay=4;  break;                                                             //---------------------------- 700 ------------- 4сек
    case 1400: delay=3;  break;                                                             //---------------------------- 1400 ------------ 3сек
    case 2100: delay=2;  break;                                                             //---------------------------- 2100 ------------ 2сек
    case 2800: delay=1;  break;                                                             //---------------------------- 2800 ------------ 1сек
    case 3500: delay=0;  break;}                                                            //---------------------------- 3500 ------------ 0сек
    tft.setTextColor(TFT_RED,TFT_GREY40); tft.drawNumber(delay,360,263,4);}                 //выводим обратное значение в секундах
  if (valNav>=NavTime){valNav=0; NPosition=1;}                                              //по истечении времени если ни один пункт не выбран выходим из навигации по меню
  if (Color==1){if(millis()-ColorMillis>=1){ColorMillis=millis(); valColor++;}              //если "Color==1" формируем задержку и
    tft.setTextColor(TFT_RED); tft.drawString("PREINSTALL",25,67,1);                        //выводим надпись "PREINSTALL" и "Single Click to Login" красным цветом
    tft.drawString("Single Click to Login",240,67,1);                                       //---------------------------------------------------------------------
  if (valColor>=TimeColor){valColor=0; Color=0; NPosition=2;}}                              //как только значение valColor становится равным TimeColor идём в предустановки
  if (Color==2){if(millis()-ColorMillis>=1){ColorMillis=millis(); valColor++;}              //если "Color==2" формируем задержку и
    tft.setTextColor(TFT_RED); tft.drawString("MENU page 1",25,133,1);                      //выводим надпись "MENU page 1" и "Double Click to Login" красным цветом
    tft.drawString("Double Click to Login",240,133,1);                                      //----------------------------------------------------------------------
  if (valColor>=TimeColor){valColor=0; Color=0; NPosition=3;}}                              //как только значение valColor становится равным TimeColor идём в меню 1
  if (Color==3){if(millis()-ColorMillis>=1){ColorMillis=millis(); valColor++;}              //если "Color==3" формируем задержку и
    tft.setTextColor(TFT_RED); tft.drawString("MENU page 2",25,199,1);                      //выводим надпись "MENU page 2" и "Triple Click to Login" красным цветом
    tft.drawString("Triple Click to Login",240,199,1);                                      //----------------------------------------------------------------------
  if (valColor>=TimeColor){valColor=0; Color=0; NPosition=4;}}}                             //как только значение valColor становится равным TimeColor идём в меню 2
  switch(NPosition){                                                                        //функция выбора позиций навигации по меню
    case 1: beep(); SetStep=1; flagtemp=false; preparing_the_screen(); break;               //если "NPosition==1" выходим из "MENU NAVIGATION" и вызываем подпрограмму подготовки экрана
    case 2: beep(); Position=0; preinstallations(); break;                                  //если "NPosition==2" входим в режим предустановок
    case 3: beep(); Position=0; menu1(); break;                                             //если "NPosition==3" входим в меню 1
    case 4: beep(); Position=0; menu2(); break;}}                                           //если "NPosition==4" входим в меню 2
void menu1(){//*********************************************** МЕНЮ 1 *******************************************************************************
M1:if (submenu==1){//********************************* Выбор цвета окантовок ************************************************************************
  switch(border){                                                                           //функция выбора цвета окантовок
    case 1: tft.setTextColor(TFT_CYAN); tft.fillRect(354,184,102,40,TFT_DARKCYAN);          //соответствующим цветом
    tft.drawCentreString("CYAN",405,199,1); break;                                          //выводим надпись "CYAN"
    case 2: tft.setTextColor(TFT_ORANGE); tft.fillRect(354,184,102,40,TFT_DARKCYAN);        //соответствующим цветом
    tft.drawCentreString("ORANGE",405,199,1); break;                                        //выводим надпись "ORANGE"
    case 3: tft.setTextColor(tft.color565(40,40,255));                                      //соответствующим цветом
    tft.fillRect(354,184,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Color selection"
    tft.drawCentreString("BLUE",405,199,1); break;                                          //выводим надпись "BLUE"
    case 4: tft.setTextColor(TFT_SILVER); tft.fillRect(354,184,102,40,TFT_DARKCYAN);        //соответствующим цветом
    tft.drawCentreString("SILVER",405,199,1); break;                                        //выводим надпись "SILVER"
    case 5: tft.setTextColor(tft.color565(0,170,0));                                        //соответствующим цветом
    tft.fillRect(354,184,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Color selection"
    tft.drawCentreString("GREEN",405,199,1); break;                                         //выводим надпись "GREEN"
    case 6: tft.setTextColor(TFT_PINK); tft.fillRect(354,184,102,40,TFT_DARKCYAN);          //соответствующим цветом
    tft.drawCentreString("PINK",405,199,1); break;}                                         //выводим надпись "PINK"
    BPosition=border;                                                                       //приравниваем значение "BPosition" к "border" для выхода из подменю без изменений
while (BPosition<7){                                                                        //находимся в подменю пока "BPosition<7"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (encoder.timeRight!=0){BPosition++; beep(); single=0;                                  //включаем счётчик вращения энкодера вправо
  if (BPosition>6){BPosition=1;} encoder.timeRight=0;}                                      //ограничиваем значение энкодера 6 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){BPosition--; beep(); single=0;                                   //включаем счётчик вращения энкодера влево
  if (BPosition<1){BPosition=6;} encoder.timeLeft=0;}                                       //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(BPosition){                                                                        //выбор цвета окантовок
    case 1: tft.setTextColor(TFT_CYAN);                                                     //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("CYAN",405,199,1);} break;                                         //выводим надпись "CYAN"
    case 2: tft.setTextColor(TFT_ORANGE);                                                   //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("ORANGE",405,199,1);} break;                                       //выводим надпись "ORANGE"
    case 3: tft.setTextColor(tft.color565(40,40,255));                                      //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("BLUE",405,199,1);} break;                                         //выводим надпись "BLUE"
    case 4: tft.setTextColor(TFT_SILVER);                                                   //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("SILVER",405,199,1);} break;                                       //выводим надпись "SILVER"
    case 5: tft.setTextColor(tft.color565(0,170,0));                                        //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("GREEN",405,199,1);} break;                                        //выводим надпись "GREEN"
    case 6: tft.setTextColor(TFT_PINK);                                                     //надпись выводится соответствующим названию цветом
  if (single==0){single++;tft.fillRect(354,184,102,40,TFT_DARKCYAN);                        //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("PINK",405,199,1);} break;}                                        //выводим надпись "PINK"
  if (butt1.isSingle()){beep(); border=BPosition; single=0 ; BPosition=7;}                  //одинарным кликом переписываем состояние "BPosition" в "border", "single" выставляем в 0
}   EEPROM.update(4,border); submenu=0;                                                     //сохраняем значение "border" в ячейку №4, сбрасываем "submenu" в 0
    tft.fillRect(354,184,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Color selection"
    tft.fillRect(189,198,102,24,TFT_DARKCYAN);                                              //затираем окно вывода надписи установленного цвета
}//****************************************************** Выход из выбора цвета *********************************************************************
    border=EEPROM.read(4);                                                                  //читаем из 4 ячейки EEPROM состояние BORDER
  switch (border){                                                                          //оператор выбора цвета окантовок
    case 1: bordercolor=TFT_CYAN; break;                                                    //если border=1 включаем голубой цвет окантовок рамки
    case 2: bordercolor=TFT_ORANGE; break;                                                  //если border=2 включаем оранжевый цвет окантовок рамки
    case 3: bordercolor=tft.color565(40,40,255); break;                                     //если border=3 включаем синий цвет окантовок рамки
    case 4: bordercolor=TFT_SILVER; break;                                                  //если border=4 включаем серебряный цвет окантовок рамки
    case 5: bordercolor=tft.color565(0,170,0); break;                                       //если border=5 включаем пурпурный цвет окантовок рамки
    case 6: bordercolor=TFT_PINK; break;}                                                   //если border=6 включаем розовый цвет окантовок рамки
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.fillRoundRect(16,45,448,60,8,TFT_DARKCYAN);                                         //рисуем прямоугольники фона для рамок вывода пунктов меню
    tft.fillRoundRect(16,111,448,60,8,TFT_DARKCYAN);                                        //--------------------------------------------------------
    tft.fillRoundRect(16,177,448,60,8,TFT_DARKCYAN);                                        //--------------------------------------------------------
    tft.drawRoundRect(19,48,442,54,8,bordercolor);                                          //рисуем внутренние рамки вывода пунктов меню
    tft.drawRoundRect(19,114,442,54,8,bordercolor);                                         //--------------------------------------------
    tft.drawRoundRect(19,180,442,54,8,bordercolor);                                         //--------------------------------------------
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRoundRect(15+i,44+i,450-i*2,62-i*2,8-i,bordercolor);                            //рисуем окантовки рамок вывода пунктов меню
    tft.drawRoundRect(15+i,110+i,450-i*2,62-i*2,8-i,bordercolor);                           //------------------------------------------
    tft.drawRoundRect(15+i,176+i,450-i*2,62-i*2,8-i,bordercolor);}                          //------------------------------------------
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18, выбираем цвет текста
    tft.drawCentreString("Double click to exit",240,262,1);                                 //выводим надпись "Double click to exit"
    tft.setFreeFont(FSSB9); tft.setTextColor(bordercolor);                                  //выбираем шрифт и цвет текста
    tft.drawString("page 1",25,20,1);                                                       //выводим надпись "page 1"
    tft.setFreeFont(FSBI12);                                                                //подключаем внешний шрифт FSBI12
    tft.drawCentreString("-- MENU --",240,17,1);                                            //выводим надпись "-- MENU --"
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста
    tft.drawString("1. TimeMEM",25,67,1);                                                   //выводим надпись "1. TimeMEM"
    tft.drawString("2. TONE BEEP",25,133,1);                                                //выводим надпись "2. TONE BEEP"
    tft.drawString("3. BORDER",25,199,1);                                                   //выводим надпись "3. Border"
    tft.fillRect(354,184,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Color selection"
    tft.fillRect(189,198,102,24,TFT_DARKCYAN);                                              //затираем окно вывода надписи установленного цвета
    tft.drawCentreString("Time",405,55,1);                                                  //выводим надпись "Time"
    tft.drawCentreString("selection",405,77,1);                                             //выводим надпись "selection"
    tft.drawCentreString("Tone",405,119,1);                                                 //выводим надпись "Tone"
    tft.drawCentreString("selection",405,141,1);                                            //выводим надпись "selection"
    tft.drawCentreString("Color",405,185,1);                                                //выводим надпись "Color"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
M2:if (submenu==1){//************************************** Выбор времени задержки ******************************************************************
    tft.setTextColor(TFT_RED,TFT_DARKCYAN);                                                 //по метке М2 если "submenu==1" выбираем цвет текста
    tft.fillRect(354,54,102,40,TFT_DARKCYAN);                                               //затираем окно вывода надписи "Tone selection"
    ClockTime=EEPROM.read(16); Time=ClockTime*100;                                          //читаем содержимое ячейки
    char buf[5]; byte len=4; dtostrf(Time,len,0,buf);                                       //формируем буфер и конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,67,4); tft.drawString("ms",420,67,4);                      //выводим значение выбираемого времени задержки в "ms"
while (Time<9001){                                                                          //находимся в подменю пока "Time<9001"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
    char buf[5]; byte len=4;                                                                //формируем буфер
  if (encoder.timeRight!=0){Time=Time+1000; beep();                                         //включаем счётчик вращения энкодера вправо
  if (Time>9000){Time=1000;} encoder.timeRight=0;}                                          //обнуляем время/признак вращения вправо
  if (encoder.timeLeft!=0){Time=Time-1000;  beep();                                         //включаем счётчик вращения энкодера влево
  if (Time<1000){Time=9000;} encoder.timeLeft=0;}                                           //обнуляем время/признак вращения влево
    dtostrf(Time,len,0,buf);                                                                //конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,67,4); tft.drawString("ms",420,67,4);                      //выводим значение выбираемого времени задержки
  if (butt1.isSingle()){beep(); ClockTime=Time/100; Time=9001;}                             //одинарным кликом
}   EEPROM.update(16,ClockTime); submenu=0;                                                 //сохраняем значение "ClockTime" в ячейку №16, сбрасываем "submenu" в 0
    tft.fillRect(354,54,102,40,TFT_DARKCYAN);                                               //затираем окно вывода надписи "Time selection"
    tft.fillRect(189,66,102,24,TFT_DARKCYAN);}                                              //затираем окно вывода надписи установленного времени задержки
M3:if (submenu==1){//*************************************** Выбор тона бипера **********************************************************************
    tft.setTextColor(TFT_RED,TFT_DARKCYAN);                                                 //по метке М2 если "submenu==1" выбираем цвет текста
    tft.fillRect(354,118,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Tone selection"
    TONE=EEPROM.read(17); BEEPER=TONE;                                                      //читаем содержимое ячейки
    char buf[5]; byte len=4;                                                                //формируем буфер для вывода символьного массива
  switch(BEEPER){
    case  0: tft.drawCentreString("OFF",405,133,1); break;                                  //если значение тона бипера равно 0 выводим "OFF"
    case  1 ... 9: dtostrf(BEEPER*100,len,0,buf);                                           //если значение тона бипера меньше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,385,131,4); tft.drawString("Hz",411,131,4); break;             //выводим значение выбираемого тона бипера в "герцах"
    case 10 ... 30: dtostrf((float)BEEPER/10,len,1,buf);                                    //если значение тона бипера больше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,385,131,4); tft.drawString("kHz",408,131,4); break;}           //выводим значение выбираемого тона бипера в "килогерцах"
while (BEEPER<31){                                                                          //находимся в подменю пока "BEEPER<31"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
    char buf[5]; byte len=4;                                                                //формируем буфер
  if (encoder.timeRight!=0){BEEPER++; if (BEEPER>30){BEEPER=0;}                             //включаем счётчик вращения энкодера вправо
    TONE=BEEPER; if (TONE!=0){tone4.tone(TONE*100); delay(50); tone4.noTone();}             //приравниваем "TONE" к "BEEPER" чтобы слышать выбираемый тон бипера
  switch(BEEPER){
    case  0: tft.drawCentreString("    OFF    ",405,133,1); break;                          //если значение тона бипера равно 0 выводим "OFF"
    case  1 ... 9: dtostrf(BEEPER*100,len,0,buf);                                           //если значение тона бипера меньше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,131,4); tft.drawString("Hz  ",411,131,4); break;           //выводим значение выбираемого тона бипера в "герцах"
    case 10 ... 30: dtostrf((float)BEEPER/10,len,1,buf);                                    //если значение тона бипера больше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,131,4); tft.drawString("kHz",408,131,4); break;}           //выводим значение выбираемого тона бипера в "килогерцах"
    encoder.timeRight=0;}                                                                   //обнуляем время/признак вращения вправо
  if (encoder.timeLeft!=0){BEEPER--; if (BEEPER<0){BEEPER=30;}                              //включаем счётчик вращения энкодера влево
    TONE=BEEPER; if (TONE!=0){tone4.tone(TONE*100); delay(50); tone4.noTone();}             //приравниваем "TONE" к "BEEPER" чтобы слышать выбираемый тон бипера
  switch(BEEPER){
    case  0: tft.drawCentreString("    OFF    ",405,133,1); break;                          //если значение тона бипера равно 0 выводим "OFF"
    case  1 ... 9: dtostrf(BEEPER*100,len,0,buf);                                           //если значение тона бипера меньше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,131,4); tft.drawString("Hz  ",411,131,4); break;           //выводим значение выбираемого тона бипера в "герцах"
    case 10 ... 30: dtostrf((float)BEEPER/10,len,1,buf);                                    //если значение тона бипера больше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,388,131,4); tft.drawString("kHz",408,131,4); break;}           //выводим значение выбираемого тона бипера в "килогерцах"
    encoder.timeLeft=0;}                                                                    //обнуляем время/признак вращения влево
  if (butt1.isSingle()){beep(); TONE=BEEPER; BEEPER=31;}                                    //одинарным кликом переписываем состояние "BEEPER" в "TONE"
}   EEPROM.update(17,TONE); submenu=0;                                                      //сохраняем значение "TONE" в ячейку №17, сбрасываем "submenu" в 0
    tft.fillRect(354,118,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Tone selection"
    tft.fillRect(189,132,102,24,TFT_DARKCYAN);                                              //затираем окно вывода надписи установленного тона бипера
}//*********************************************** Выход из выбора задержки и тона ******************************************************************
    ClockTime=EEPROM.read(16);                                                              //читаем содержимое ячейки
    tft.setTextColor(TFT_SILVER);                                                           //выбираем цвет текста
    char buf[5]; byte len=4; dtostrf(ClockTime*100,len,0,buf);                              //формируем буфер и конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,225,67,4); tft.drawString("ms",255,67,4);                      //выводим значение выбираемого тона бипера в "ms"
    TONE=EEPROM.read(17); BEEPER=TONE;                                                      //читаем содержимое ячейки
    tft.setTextColor(TFT_SILVER);                                                           //выбираем цвет текста
  switch(BEEPER){
    case  0: tft.drawCentreString("OFF",240,133,1); break;                                  //если значение тона бипера равно 0 выводим "OFF"
    case  1 ... 9: dtostrf(BEEPER*100,len,0,buf);                                           //если значение тона бипера меньше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,225,131,4); tft.drawString("Hz",248,131,4); break;             //выводим значение выбираемого тона бипера в "герцах"
    case 10 ... 30: dtostrf((float)BEEPER/10,len,1,buf);                                    //если значение тона бипера больше 1000 конвертируем символьный массив вывода данных
    tft.drawCentreString(buf,220,131,4); tft.drawString("kHz",243,131,4); break;}           //выводим значение выбираемого тона бипера в "килогерцах"
    border=EEPROM.read(4);                                                                  //читаем содержимое ячейки
  switch(border){                                                                           //функция выбора цвета надписи
    case 1: tft.setTextColor(TFT_CYAN);                                                     //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("CYAN",240,199,1); break;                                          //если значение ячейки 4 EEPROM равно 1, выводим реальные значения
    case 2: tft.setTextColor(TFT_ORANGE);                                                   //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("ORANGE",240,199,1); break;                                        //если значение ячейки 4 EEPROM равно 2  -------------------------
    case 3: tft.setTextColor(tft.color565(40,40,255));                                      //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("BLUE",240,199,1); break;                                          //если значение ячейки 4 EEPROM равно 3  -------------------------
    case 4: tft.setTextColor(TFT_SILVER);                                                   //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("SILVER",240,199,1); break;                                        //если значение ячейки 4 EEPROM равно 4  -------------------------
    case 5: tft.setTextColor(tft.color565(0,170,0));                                        //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("GREEN",240,199,1); break;                                         //если значение ячейки 4 EEPROM равно 5  -------------------------
    case 6: tft.setTextColor(TFT_PINK);                                                     //выбираем цвет надписи установленного значения цвета окантовок
    tft.drawCentreString("PINK",240,199,1); break;}                                         //если значение ячейки 4 EEPROM равно 6  -------------------------
while (Position<4){                                                                         //находимся в меню пока "Position<4"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (butt1.isDouble()){beep(); Position=4;}                                                //двойным кликом получаем "Position=4" и выходим из режима меню
  if (encoder.timeRight!=0){Position++; beep();                                             //включаем счётчик вращения энкодера вправо
  if (Position>3){Position=1;} encoder.timeRight=0;}                                        //ограничиваем значение энкодера 4 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){Position--; beep();                                              //включаем счётчик вращения энкодера влево
  if (Position<1){Position=3;} encoder.timeLeft=0;}                                         //ограничиваем значение энкодера 0 импульсов, работает по кольцу
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста восстановления надписей
  switch(Position){                                                                         //выбор позиций меню
  case 1: tft.drawString("3. BORDER",25,199,1);                                             //если "Position==1" восстанавливаем надпись "3. BORDER" зелёным цветом
    tft.drawCentreString("Color",405,185,1);                                                //выводим надпись "Color"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
    tft.drawString("2. TONE BEEP",25,133,1);                                                //восстанавливаем надпись "2. TONE BEEP" зелёным цветом
    tft.drawCentreString("Tone",405,119,1);                                                 //выводим надпись "Tone"
    tft.drawCentreString("selection",405,141,1);                                            //выводим надпись "selection"
    tft.setTextColor(TFT_RED); tft.drawString("1. TimeMEM",25,67,1);                        //выводим надпись "1. TimeMEM" красным цветом
    tft.drawCentreString("Time",405,55,1);                                                  //выводим надпись "Time"
    tft.drawCentreString("selection",405,77,1);                                             //выводим надпись "selection"
  if (butt1.isDouble()){beep(); Position=4;}                                                //двойным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); MPosition=0; submenu=1; goto M2;} break;                    //одиночным кликом на кнопку энкодера уходим по метке М2 в подменю выбора времени задержки
  case 2: tft.drawString("1. TimeMEM",25,67,1);                                             //если "MPosition==2" восстанавливаем надпись "1. TimeMEM" зелёным цветом
    tft.drawCentreString("Time",405,55,1);                                                  //выводим надпись "Time"
    tft.drawCentreString("selection",405,77,1);                                             //выводим надпись "selection"
    tft.drawString("3. BORDER",25,199,1);                                                   //восстанавливаем надпись "3. BORDER" зелёным цветом
    tft.drawCentreString("Color",405,185,1);                                                //выводим надпись "Color"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
    tft.setTextColor(TFT_RED); tft.drawString("2. TONE BEEP",25,133,1);                     //выводим надпись "2. TONE BEEP" красным цветом
    tft.drawCentreString("Tone",405,119,1);                                                 //выводим надпись "Tone"
    tft.drawCentreString("selection",405,141,1);                                            //выводим надпись "selection"
  if (butt1.isDouble()){beep(); Position=4;}                                                //двойным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); BEEPER=TONE; submenu=1; goto M3;} break;                    //одиночным кликом на кнопку энкодера уходим по метке М3 в подменю выбора тона бипера
  case 3: tft.drawString("2. TONE BEEP",25,133,1);                                          //если "Position==3" восстанавливаем надпись "2. TONE BEEP" зелёным цветом
    tft.drawCentreString("Tone",405,119,1);                                                 //выводим надпись "Tone"
    tft.drawCentreString("selection",405,141,1);                                            //выводим надпись "selection"
    tft.drawString("1. TimeMEM",25,67,1);                                                   //восстанавливаем надпись "1. TimeMEM" зелёным цветом
    tft.drawCentreString("Time",405,55,1);                                                  //выводим надпись "Time"
    tft.drawCentreString("selection",405,77,1);                                             //выводим надпись "selection"
    tft.setTextColor(TFT_RED); tft.drawString("3. BORDER",25,199,1);                        //выводим надпись "3. BORDER" красным цветом
    tft.drawCentreString("Color",405,185,1);                                                //выводим надпись "Color"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
  if (butt1.isDouble()){beep(); Position=4;}                                                //двойным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); BPosition=0; submenu=1; goto M1;} break;}                   //одиночным кликом на кнопку энкодера уходим по метке М1 в подменю выбора цвета окантовок
}   SetStep=1; flagtemp=false;                                                              //"SetStep" выставляем в 1 для индикации "Setting" после выхода из меню
    preparing_the_screen();}                                                                //выходим из "MENU 1" и вызываем подпрограмму подготовки экрана
void menu2(){//********************************************** МЕНЮ 2 ********************************************************************************
M1:if (submenu==1){//******************************* Выбор ориентации дисплея ***********************************************************************
    tft.fillRect(354,54,102,44,TFT_DARKCYAN);                                               //затираем окно вывода надписи "Rotation setting"
    tft.setTextColor(TFT_RED);                                                              //по метке М1 если "submenu==1" выбираем цвет текста
    RotDisp=EEPROM.read(14);                                                                //читаем значение ячейки
  if (RotDisp==1){tft.drawCentreString("INV",410,67,1);}                                    //если значение ячейки 14 EEPROM равно 1, выводим реальные значения
  if (RotDisp==3){tft.drawCentreString("NORM",410,67,1);}                                   //если значение ячейки 14 EEPROM равно 3  -------------------------
while (Position<1){                                                                         //находимся в подменю пока "Position<1"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (RotDisp==1){RotDisp=3;                                                                //если "RotDisp==1"
  if (single==0){single++; tft.fillRect(374,67,73,17,TFT_DARKCYAN);                         //затираем предыдущую надпись
    tft.drawCentreString("NORM",410,67,1); EEPROM.update(14,RotDisp);}}                     //выводим надпись "NORM" красным цветом
  if (RotDisp==3){RotDisp=1;                                                                //если "RotDisp==3"
  if (single==0){single++; tft.fillRect(374,67,73,17,TFT_DARKCYAN);                         //затираем предыдущую надпись
    tft.drawCentreString("INV",410,67,1); EEPROM.update(14,RotDisp);}}                      //выводим надпись "INV" красным цветом
  if (butt1.isSingle()){beep(); Position=1;}                                                //одинарным кликом 
}   single=0; submenu=0;}                                                                   //сбрасываем "single" и "submenu" в 0 и выходим из подменю
M2:if (submenu==1){//********************************* Выбор инверсии цвета *************************************************************************
    tft.fillRect(354,118,102,44,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Inversion setting"
    tft.setTextColor(TFT_RED);                                                              //по метке М1 если "submenu==1" выбираем цвет текста
    InvDisp=EEPROM.read(13);                                                                //читаем значение ячейки
  if (InvDisp==0){tft.drawCentreString("NORM",410,133,1);}                                  //если значение ячейки 13 EEPROM равно 1, выводим противоположные значения
  if (InvDisp==1){tft.drawCentreString("INV",410,133,1);}                                   //если значение ячейки 13 EEPROM равно 3  --------------------------------
while (Position<2){                                                                         //находимся в подменю пока "Position<2"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (InvDisp==0){InvDisp=1;                                                                //если "InvDisp==0"
  if (single==0){single++; tft.fillRect(374,133,73,17,TFT_DARKCYAN);                        //затираем предыдущую надпись
    tft.drawCentreString("INV",410,133,1); EEPROM.update(13,InvDisp);}}                     //выводим надпись "INV" красным цветом
  if (InvDisp==1){InvDisp=0;                                                                //если "InvDisp==1"
  if (single==0){single++; tft.fillRect(374,133,73,17,TFT_DARKCYAN);                        //затираем предыдущую надпись
    tft.drawCentreString("NORM",410,133,1); EEPROM.update(13,InvDisp);}}                    //выводим надпись "NORM" красным цветом
  if (butt1.isSingle()){beep(); Position=2;}                                                //одинарным кликом 
}   single=0; submenu=0;                                                                    //сбрасываем "single" и "submenu" в 0 и выходим из подменю
}//***************************************** Выход из выбора ориентации и инверсии ******************************************************************
    tft.invertDisplay(EEPROM.read(13));                                                     //читаем содержимое ячейки 13 и выводим нормальный или инверсный цвет дисплея
    tft.setRotation(EEPROM.read(14));                                                       //читаем содержимое ячейки 14 и выводим соответствующую ориентацию дисплея
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.fillRoundRect(16,45,448,60,8,TFT_DARKCYAN);                                         //рисуем прямоугольник фона для рамки вывода пункта меню
    tft.fillRoundRect(16,111,448,60,8,TFT_DARKCYAN);                                        //------------------------------------------------------
    tft.fillRoundRect(16,177,448,60,8,TFT_DARKCYAN);                                        //------------------------------------------------------
    tft.drawRoundRect(19,48,442,54,8,bordercolor);                                          //рисуем внутреннюю рамку вывода пункта меню
    tft.drawRoundRect(19,114,442,54,8,bordercolor);                                         //------------------------------------------
    tft.drawRoundRect(19,180,442,54,8,bordercolor);                                         //------------------------------------------
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRoundRect(15+i,44+i,450-i*2,62-i*2,8-i,bordercolor);                            //рисуем окантовку рамки вывода пункта меню
    tft.drawRoundRect(15+i,110+i,450-i*2,62-i*2,8-i,bordercolor);                           //-----------------------------------------
    tft.drawRoundRect(15+i,176+i,450-i*2,62-i*2,8-i,bordercolor);}                          //-----------------------------------------
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18, выбираем цвет текста
    tft.drawCentreString("Triple click to exit",240,262,1);                                 //выводим надпись "Triple click to exit"
    tft.setFreeFont(FSSB9); tft.setTextColor(bordercolor);                                  //выбираем шрифт и цвет текста
    tft.drawString("page 2",25,20,1);                                                       //выводим надпись "page 2"
    tft.setFreeFont(FSBI12);                                                                //подключаем внешний шрифт FSBI12
    tft.drawCentreString("-- MENU --",240,17,1);                                            //выводим надпись "-- MENU --"
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста
    tft.drawString("4. ROTATION",25,67,1);                                                  //выводим надпись "4. ROTATION"
    tft.drawString("5. INVERSION",25,133,1);                                                //выводим надпись "5. INVERSION"
    tft.drawString("6. STEP",25,199,1);                                                     //выводим надпись "6. STEP"
    tft.fillRect(352,66,105,25,TFT_DARKCYAN);                                               //затираем окно вывода надписи "Rotation setting"
    tft.drawCentreString("Rotation",405,55,1);                                              //выводим надпись "Rotation"
    tft.drawCentreString("setting",405,77,1);                                               //выводим надпись "setting"
    tft.fillRect(352,132,105,25,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Inversion setting"
    tft.drawCentreString("Inversion",405,119,1);                                            //выводим надпись "Inversion"
    tft.drawCentreString("setting",405,141,1);                                              //выводим надпись "setting"
    tft.fillRect(352,184,105,45,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Step selection"
    tft.drawCentreString("Step",405,185,1);                                                 //выводим надпись "Step"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
    InvDisp=EEPROM.read(13); RotDisp=EEPROM.read(14);                                       //читаем значения ячеек
    tft.setTextColor(TFT_SILVER);                                                           //выбираем цвет текста
  if (RotDisp==1){tft.drawCentreString("INV",240,67,1);}                                    //если значение ячейки 14 EEPROM равно 1, выводим реальные значения
  if (RotDisp==3){tft.drawCentreString("NORM",240,67,1);}                                   //если значение ячейки 14 EEPROM равно 3  -------------------------
  if (InvDisp==0){tft.drawCentreString("NORM",240,133,1);}                                  //если значение ячейки 13 EEPROM равно 0, выводим реальное значение
  if (InvDisp==1){tft.drawCentreString("INV",240,133,1);}                                   //если значение ячейки 13 EEPROM равно 1  -------------------------
M3:if (submenu==1){//************************************** Выбор шага датчика **********************************************************************
    tft.fillRect(354,184,102,40,TFT_DARKCYAN);                                              //затираем окно вывода надписи "Step selection"
    tft.setTextColor(TFT_RED);                                                              //выбираем цвет текста
  switch(stp){                                                                              //функция выбора количества°
    case 1: tft.drawCentreString("    1    ",405,199,1);                                    //выводим надпись "1.0"
    tft.drawString(".   ",420,186,1); break;                                                //выводим символ "°"
    case 2: tft.drawCentreString("    5    ",405,199,1);                                    //выводим надпись "5.0"
    tft.drawString(".   ",420,186,1); break;                                                //выводим символ "°"
    case 3: tft.drawCentreString("   10   ",405,199,1);                                     //выводим надпись "10.0"
    tft.drawString(".",425,186,1); break;                                                   //выводим символ "°"
    case 4: tft.drawCentreString("   15   ",405,199,1);                                     //выводим надпись "15.0"
    tft.drawString(".",425,186,1); break;                                                   //выводим символ "°"
    case 5: tft.drawCentreString("22.5",408,199,1);                                         //выводим надпись "22.5"
    tft.drawString(".",430,186,1); break;}                                                  //выводим символ "°"
    SPosition=stp;                                                                          //приравниваем переменную выбора шага датчика к текущему шагу
while (SPosition<6){                                                                        //находимся в подменю пока "SPosition<6"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (encoder.timeRight!=0){SPosition++; beep(); single=0;                                  //включаем счётчик вращения энкодера вправо
  if (SPosition>5){SPosition=1;} encoder.timeRight=0;}                                      //ограничиваем значение энкодера 5 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){SPosition--; beep(); single=0;                                   //включаем счётчик вращения энкодера влево
  if (SPosition<1){SPosition=5;} encoder.timeLeft=0;}                                       //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(SPosition){                                                                        //выбор шага датчика
  case 1: tft.setTextColor(TFT_RED);                                                        //надпись выводится красным цветом
  if (single==0){single++; tft.fillRect(354,184,102,40,TFT_DARKCYAN);                       //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("    1    ",405,199,1);                                            //выводим надпись "1.0"
    tft.drawString(".   ",420,186,1);} break;                                               //выводим символ "°"
  case 2: tft.setTextColor(TFT_RED);                                                        //надпись выводится красным цветом
  if (single==0){single++; tft.fillRect(354,184,102,40,TFT_DARKCYAN);                       //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("    5    ",405,199,1);                                            //выводим надпись "5.0"
    tft.drawString(".   ",420,186,1);} break;                                               //выводим символ "°"
  case 3: tft.setTextColor(TFT_RED);                                                        //надпись выводится красным цветом
  if (single==0){single++; tft.fillRect(354,184,102,40,TFT_DARKCYAN);                       //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("   10   ",405,199,1);                                             //выводим надпись "10.0"
    tft.drawString(".",425,186,1);} break;                                                  //выводим символ "°"
  case 4: tft.setTextColor(TFT_RED);                                                        //надпись выводится красным цветом
  if (single==0){single++; tft.fillRect(354,184,102,40,TFT_DARKCYAN);                       //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("   15   ",405,199,1);                                             //выводим надпись "15.0"
    tft.drawString(".",425,186,1);} break;                                                  //выводим символ "°"
  case 5: tft.setTextColor(TFT_RED);                                                        //надпись выводится красным цветом
  if (single==0){single++; tft.fillRect(354,184,102,40,TFT_DARKCYAN);                       //включаем счётчик "single" для однократного вывода надписи, рисуем затиралку
    tft.drawCentreString("22.5",408,199,1);                                                 //выводим надпись "22.5"
    tft.drawString(".",430,186,1);} break;}                                                 //выводим символ "°"
  if (butt1.isSingle()){beep(); stp=SPosition; single=0; SPosition=6;}                      //одиночным кликом выставляем "SPosition" равным 6 и выходим из цикла "SPosition"
} if (sensor!=0){                                                                           //если антенна находится не на 0°
while (digitalRead(Terminal)==HIGH){                                                        //пока на "Terminal" высокий уровень
    digitalWrite(Right,LOW);digitalWrite(Left,HIGH);                                        //включаем движение антенны к азимуту 0°
  if (single==0){single++; tft.fillRect(352,184,105,45,TFT_DARKCYAN);                       //затираем окно "Step selection" и "single" включаем счётчиком для однократного
    tft.drawCentreString("Going to",405,185,1);                                             //вывода надписи "Going to"
    tft.drawCentreString("azimuth 0",402,207,1);                                            //-------------- "azimuth 0"
    tft.drawString(".",452,207-13,1);}}}                                                    //-------------- с символом "°" в конце
  if (digitalRead(Terminal)==LOW){digitalWrite(Right,LOW); digitalWrite(Left,LOW);          //если на "Terminal" низкий уровень движение антенны прекращается
    EEPROM.update(0,0); EEPROM.update(1,0); EEPROM.update(5,0);EEPROM.update(6,0);          //сохраняем результат коррекции в EEPROM
    Sensor=word(EEPROM.read(0),EEPROM.read(1)); sensor=Sensor;                              //читаем положение антенны
    Pencoder=word(EEPROM.read(5),EEPROM.read(6)); pencoder=Pencoder;                        //и значение установки движения антенны из EEPROM
  for(int i=700; i<1200; i++){tone4.tone(i);                                                //устанавливаем изменение тональности бипера окончания коррекции
    delay(1);} tone4.noTone(); single=0;}                                                   //формируем длительность изменяемых частот, отключаем бипер и "single" сбрасываем в 0
    EEPROM.update(15,stp); submenu=0;                                                       //запоминаем выбранное значение и сбрасываем "submenu" в 0
    tft.fillRect(352,184,105,45,TFT_DARKCYAN); mmt=0; sst=0;                                //затираем окно "Step selection", обнуляем таймер и выходим из подменю шага датчика
}//*************************************************** Выход из выбора шага датчика *****************************************************************
    stp=EEPROM.read(15);                                                                    //читаем значение ячейки
    tft.setTextColor(TFT_SILVER,TFT_DARKCYAN);                                              //выбираем цвет надписи и подложки
  switch(stp){                                                                              //функция выбора шага датчика антенны
    case 1: tft.drawCentreString("    1    ",235,199,1);                                    //если значение ячейки 15 равно 1 выводим шаг 1°
    tft.drawString(".",252,186,1); break;                                                   //выводим символ "°"
    case 2: tft.drawCentreString("    5    ",235,199,1);                                    //если значение ячейки 15 равно 2 выводим шаг 5°
    tft.drawString(".",252,186,1); break;                                                   //выводим символ "°"
    case 3: tft.drawCentreString("   10   ",232,199,1);                                     //если значение ячейки 15 равно 3 выводим шаг 10°
    tft.drawString(".",252,186,1); break;                                                   //выводим символ "°"
    case 4: tft.drawCentreString("   15   ",232,199,1);                                     //если значение ячейки 15 равно 4 выводим шаг 15°
    tft.drawString(".",252,186,1); break;                                                   //выводим символ "°"
    case 5: tft.drawCentreString("22.5",230,199,1);                                         //если значение ячейки 15 равно 5 выводим шаг 22.5°
    tft.drawString(".",252,186,1); break;}                                                  //выводим символ "°"
while (Position<4){                                                                         //находимся в подменю пока "Position<4"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  if (butt1.isTriple()){beep(); Position=4;}                                                //тройным кликом получаем "Position=4" и выходим из режима меню
  if (encoder.timeRight!=0){Position++; beep();                                             //включаем счётчик вращения энкодера вправо
  if (Position>3){Position=1;} encoder.timeRight=0;}                                        //ограничиваем значение энкодера 3 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){Position--; beep();                                              //включаем счётчик вращения энкодера влево
  if (Position<1){Position=3;} encoder.timeLeft=0;}                                         //ограничиваем значение энкодера 0 импульсов, работает по кольцу
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста
  switch(Position){                                                                         //выбор поворота изображения и инверсии цвета
  case 1: tft.drawString("6. STEP",25,199,1);                                               //восстанавливаем надпись "6. STEP" зелёным цветом
    tft.drawCentreString("Step",405,185,1);                                                 //выводим надпись "Step"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
    tft.drawString("5. INVERSION",25,133,1);                                                //восстанавливаем надпись "5. INVERSION" зелёным цветом
    tft.drawCentreString("Inversion",405,119,1);                                            //выводим надпись "Inversion"
    tft.drawCentreString("setting",405,141,1);                                              //выводим надпись "setting"
    tft.setTextColor(TFT_RED); tft.drawString("4. ROTATION",25,67,1);                       //выводим надпись "4. ROTATION" красным цветом
    tft.drawCentreString("Rotation",405,55,1);                                              //выводим надпись "Rotation"
    tft.drawCentreString("setting",405,77,1);                                               //выводим надпись "setting"
  if (butt1.isTriple()){beep(); Position=4;}                                                //тройным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); Position=0; submenu=1; goto M1;} break;                     //одинарным кликом переходим по метке М1 в подменю выбора ориентации дисплея
  case 2: tft.drawString("4. ROTATION",25,67,1);                                            //восстанавливаем надпись "4. ROTATION" зелёным цветом
    tft.drawCentreString("Rotation",405,55,1);                                              //выводим надпись "Rotation"
    tft.drawCentreString("setting",405,77,1);                                               //выводим надпись "setting"
    tft.drawString("6. STEP",25,199,1);                                                     //восстанавливаем надпись "6. STEP" зелёным цветом
    tft.drawCentreString("Step",405,185,1);                                                 //выводим надпись "Step"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
    tft.setTextColor(TFT_RED); tft.drawString("5. INVERSION",25,133,1);                     //выводим надпись "5. INVERSION" красным цветом
    tft.drawCentreString("Inversion",405,119,1);                                            //выводим надпись "Inversion"
    tft.drawCentreString("setting",405,141,1);                                              //выводим надпись "setting"
  if (butt1.isTriple()){beep(); Position=4;}                                                //тройным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); Position=0; submenu=1; goto M2;} break;                     //одинарным кликом переходим по метке М2 в подменю выбора инверсии цвета
  case 3: tft.drawString("5. INVERSION",25,133,1);                                          //если "MPosition==3" восстанавливаем надпись "5. INVERSION" зелёным цветом
    tft.drawCentreString("Inversion",405,119,1);                                            //выводим надпись "Inversion"
    tft.drawCentreString("setting",405,141,1);                                              //выводим надпись "setting"
    tft.drawString("4. ROTATION",25,67,1);                                                  //восстанавливаем надпись "4. ROTATION" зелёным цветом
    tft.drawCentreString("Rotation",405,55,1);                                              //выводим надпись "Rotation"
    tft.drawCentreString("setting",405,77,1);                                               //выводим надпись "setting"
    tft.setTextColor(TFT_RED); tft.drawString("6. STEP",25,199,1);                          //выводим надпись "6. STEP" красным цветом
    tft.drawCentreString("Step",405,185,1);                                                 //выводим надпись "Step"
    tft.drawCentreString("selection",405,207,1);                                            //выводим надпись "selection"
  if (butt1.isTriple()){beep(); Position=4;}                                                //тройным кликом получаем "Position=4" и выходим из режима меню
  if (butt1.isSingle()){beep(); SPosition=0; submenu=1; goto M3;} break;}                   //одинарным кликом уходим по метке М1 в подменю выбора шага датчика
}   SetStep=1; flagtemp=false;                                                              //"SetStep" выставляем в 1 для индикации "Setting" после выхода из режима "MENU 2"
    preparing_the_screen();}                                                                //выходим из "MENU 2" и вызываем подпрограмму подготовки экрана
void preinstallations(){//************************************* Предустановки ***********************************************************************
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI12); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI12 и выбираем цвет надписи "-- PREINSTALLATIONS --"
    tft.drawCentreString("-- PREINSTALLATIONS --",240,20,1);                                //выводим надпись "-- PREINSTALLATIONS --"
    tft.setTextColor(TFT_GREEN);                                                            //выбираем цвет текста и подложки
    tft.drawString("1. Canada",25,50,1);                                                    //выводим надпись "1. Canada"
    tft.drawString("2. Northern America",25,83,1);                                          //выводим надпись "2. Northern America"
    tft.drawString("3. Latin America",25,116,1);                                            //выводим надпись "3. Latin America"
    tft.drawString("4. Europe",25,149,1);                                                   //выводим надпись "4. Europe"
    tft.drawString("5. Japan",25,182,1);                                                    //выводим надпись "5. Japan"
    tft.drawString("6. India",25,215,1);                                                    //выводим надпись "6. India"
    tft.drawString("7. Australia",25,248,1);                                                //выводим надпись "7. Australia"
    tft.drawString("8. Africa",25,281,1);                                                   //выводим надпись "8. Africa"
  if (number==360){                                                                         //если выбран датчик на 360 импульсов
    can=word(EEPROM.read(42),EEPROM.read(43));                                              //считываем из EEPROM значения предустановок
    nam=word(EEPROM.read(44),EEPROM.read(45));                                              //------------------------------------------
    lam=word(EEPROM.read(46),EEPROM.read(47));                                              //------------------------------------------
    eur=word(EEPROM.read(48),EEPROM.read(49));                                              //------------------------------------------
    jap=word(EEPROM.read(50),EEPROM.read(51));                                              //------------------------------------------
    ind=word(EEPROM.read(52),EEPROM.read(53));                                              //------------------------------------------
    aus=word(EEPROM.read(54),EEPROM.read(55));                                              //------------------------------------------
    afr=word(EEPROM.read(56),EEPROM.read(57));}                                             //------------------------------------------
  if (number==72){                                                                          //если выбран датчик на 72 импульсов
    can72=EEPROM.read(58);  nam72=EEPROM.read(59);  lam72=EEPROM.read(60);                  //считываем из EEPROM значения предустановок
    eur72=EEPROM.read(61);  jap72=EEPROM.read(62);  ind72=EEPROM.read(63);                  //------------------------------------------
    aus72=EEPROM.read(64);  afr72=EEPROM.read(65);}                                         //------------------------------------------
  if (number==36){                                                                          //если выбран датчик на 36 импульсов
    can36=EEPROM.read(18);  nam36=EEPROM.read(19);  lam36=EEPROM.read(20);                  //считываем из EEPROM значения предустановок
    eur36=EEPROM.read(21);  jap36=EEPROM.read(22);  ind36=EEPROM.read(23);                  //------------------------------------------
    aus36=EEPROM.read(24);  afr36=EEPROM.read(25);}                                         //------------------------------------------
  if (number==24){                                                                          //если выбран датчик на 24 импульса
    can24=EEPROM.read(26);  nam24=EEPROM.read(27);  lam24=EEPROM.read(28);                  //считываем из EEPROM значения предустановок
    eur24=EEPROM.read(29);  jap24=EEPROM.read(30);  ind24=EEPROM.read(31);                  //------------------------------------------
    aus24=EEPROM.read(32);  afr24=EEPROM.read(33);}                                         //------------------------------------------
  if (number==16){                                                                          //если выбран датчик на 16 импульсов
    can16=EEPROM.read(34);  nam16=EEPROM.read(35);  lam16=EEPROM.read(36);                  //считываем из EEPROM значения предустановок
    eur16=EEPROM.read(37);  jap16=EEPROM.read(38);  ind16=EEPROM.read(39);                  //------------------------------------------
    aus16=EEPROM.read(40);  afr16=EEPROM.read(41);}                                         //------------------------------------------
    int y,pos;                                                                              //переменные вывода на экран значений азимутов
M1:if (submenu==1){//*************************** Коррекция азимутов предустановок *******************************************************************
    tft.setTextColor(bordercolor,TFT_GREY40);                                               //выбираем шрифт и цвет текста, выбранный в "border" и цвет подложки
    char buf[5]; byte len=4;                                                                //формируем буфер для вывода символьного массива
  if (number==360){                                                                         //если количество импульсов 360
while (azimuth<361){                                                                        //находимся в цикле пока azimuth<361
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; azimuth=can; break;                                                      //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; azimuth=nam; break;                                                      //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; azimuth=lam; break;                                                      //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; azimuth=eur; break;                                                      //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; azimuth=jap; break;                                                      //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; azimuth=ind; break;                                                      //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; azimuth=aus; break;                                                      //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; azimuth=afr; break;}                                                     //если "Position=8" -------------------------------------------- Африки
  if (encoder.timeRight!=0){azimuth++; beep(); single=0;                                    //включаем счётчик вращения энкодера вправо
  if (azimuth>360){azimuth=0;} encoder.timeRight=0;}                                        //ограничиваем значение энкодера 360 импульсов
  if (encoder.timeLeft!=0){azimuth--; beep(); single=0;                                     //включаем счётчик вращения энкодера влево
  if (azimuth<0){azimuth=360;} encoder.timeLeft=0;}                                         //ограничиваем значение энкодера 0 импульсов
  switch(Position){                                                                         //функция выбора координаты "y" после коррекции
    case 1: y= 48; can=azimuth; break;                                                      //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; nam=azimuth; break;                                                      //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; lam=azimuth; break;                                                      //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; eur=azimuth; break;                                                      //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; jap=azimuth; break;                                                      //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; ind=azimuth; break;                                                      //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; aus=azimuth; break;                                                      //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; afr=azimuth; break;}                                                     //если "Position=8" -------------------------------------------- Африки
  if (single==0){single++;                                                                  //включаем "single" счётчиком чтобы вывести координаты один раз
    dtostrf(azimuth,len,0,buf);                                                             //конвертируем символьный массив вывода данных
    tft.setTextPadding(46); tft.drawCentreString(buf,430,y,4);                              //выводим значение азимута
    tft.setTextPadding(0); tft.drawString(".",455,y-13,1);}                                 //с символом "°" в конце
  if (butt1.isSingle()){beep(); single=0; azimuth=361;}                                     //двойным кликом выставляем "single=0" и "azimuth=361"
}   EEPROM.update(42,highByte(can)); EEPROM.update(43,lowByte(can));                        //сохраняем полученные значения в ячейки EEPROM
    EEPROM.update(44,highByte(nam)); EEPROM.update(45,lowByte(nam));                        //---------------------------------------------
    EEPROM.update(46,highByte(lam)); EEPROM.update(47,lowByte(lam));                        //---------------------------------------------
    EEPROM.update(48,highByte(eur)); EEPROM.update(49,lowByte(eur));                        //---------------------------------------------
    EEPROM.update(50,highByte(jap)); EEPROM.update(51,lowByte(jap));                        //---------------------------------------------
    EEPROM.update(52,highByte(ind)); EEPROM.update(53,lowByte(ind));                        //---------------------------------------------
    EEPROM.update(54,highByte(aus)); EEPROM.update(55,lowByte(aus));                        //---------------------------------------------
    EEPROM.update(56,highByte(afr)); EEPROM.update(57,lowByte(afr));                        //---------------------------------------------
    submenu=0; goto M2;}                                                                    //сбрасываем "flag_correction" в 0 и выходим из режима коррекции по метке М2
  if (number==72){                                                                          //если количество импульсов 72
while (azimuth<73){                                                                         //находимся в цикле пока azimuth<73
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; azimuth=can72; break;                                                    //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; azimuth=nam72; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; azimuth=lam72; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; azimuth=eur72; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; azimuth=jap72; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; azimuth=ind72; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; azimuth=aus72; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; azimuth=afr72; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (encoder.timeRight!=0){azimuth++; beep(); single=0;                                    //включаем счётчик вращения энкодера вправо
  if (azimuth>72){azimuth=0;} encoder.timeRight=0;}                                         //ограничиваем значение энкодера 72 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){azimuth--; beep(); single=0;                                     //включаем счётчик вращения энкодера влево
  if (azimuth<0){azimuth=72;} encoder.timeLeft=0;}                                          //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; can72=azimuth; break;                                                    //если "Position=1" -------------------------------------------- Канады
    case 2: y= 81; nam72=azimuth; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; lam72=azimuth; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; eur72=azimuth; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; jap72=azimuth; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; ind72=azimuth; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; aus72=azimuth; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; afr72=azimuth; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (single==0){single++;                                                                  //включаем "single" счётчиком чтобы вывести координаты один раз
    dtostrf(azimuth*5,len,0,buf);                                                           //конвертируем символьный массив вывода данных
    tft.setTextPadding(46); tft.drawCentreString(buf,430,y,4);                              //выводим значение азимута
    tft.setTextPadding(0); tft.drawString(".",455,y-13,1);}                                 //с символом "°" в конце
  if (butt1.isSingle()){beep(); single=0; azimuth=73;}                                      //двойным кликом выставляем "single=0" и "azimuth=73"
}   EEPROM.update(58,can72); EEPROM.update(59,nam72);                                       //сохраняем полученные значения в ячейки EEPROM
    EEPROM.update(60,lam72); EEPROM.update(61,eur72);                                       //---------------------------------------------
    EEPROM.update(62,jap72); EEPROM.update(63,ind72);                                       //---------------------------------------------
    EEPROM.update(64,aus72); EEPROM.update(65,afr72);                                       //---------------------------------------------
    submenu=0; goto M2;}                                                                    //сбрасываем "submenu" в 0 и выходим из режима коррекции по метке М2
  if (number==36){                                                                          //если количество импульсов 36
while (azimuth<37){                                                                         //находимся в цикле пока azimuth<37
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; azimuth=can36; break;                                                    //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; azimuth=nam36; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; azimuth=lam36; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; azimuth=eur36; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; azimuth=jap36; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; azimuth=ind36; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; azimuth=aus36; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; azimuth=afr36; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (encoder.timeRight!=0){azimuth++; beep(); single=0;                                    //включаем счётчик вращения энкодера вправо
  if (azimuth>36){azimuth=0;} encoder.timeRight=0;}                                         //ограничиваем значение энкодера 36 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){azimuth--; beep(); single=0;                                     //включаем счётчик вращения энкодера влево
  if (azimuth<0){azimuth=36;} encoder.timeLeft=0;}                                          //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; can36=azimuth; break;                                                    //если "Position=1" -------------------------------------------- Канады
    case 2: y= 81; nam36=azimuth; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; lam36=azimuth; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; eur36=azimuth; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; jap36=azimuth; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; ind36=azimuth; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; aus36=azimuth; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; afr36=azimuth; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (single==0){single++;                                                                  //включаем "single" счётчиком чтобы вывести координаты один раз
    dtostrf(azimuth*10,len,0,buf);                                                          //конвертируем символьный массив вывода данных
    tft.setTextPadding(46); tft.drawCentreString(buf,430,y,4);                              //выводим значение азимута
    tft.setTextPadding(0); tft.drawString(".",455,y-13,1);}                                 //с символом "°" в конце
  if (butt1.isSingle()){beep(); single=0; azimuth=37;}                                      //однократным кликом выставляем "single=0" и "azimuth=37"
}   EEPROM.update(18,can36); EEPROM.update(19,nam36);                                       //сохраняем полученные значения в ячейки EEPROM
    EEPROM.update(20,lam36); EEPROM.update(21,eur36);                                       //---------------------------------------------
    EEPROM.update(22,jap36); EEPROM.update(23,ind36);                                       //---------------------------------------------
    EEPROM.update(24,aus36); EEPROM.update(25,afr36);                                       //---------------------------------------------
    submenu=0; goto M2;}                                                                    //сбрасываем "submenu" в 0 и выходим из режима коррекции по метке М2
  if (number==24){                                                                          //если количество импульсов 24
while (azimuth<25){                                                                         //находимся в цикле пока azimuth<25
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; azimuth=can24; break;                                                    //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; azimuth=nam24; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; azimuth=lam24; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; azimuth=eur24; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; azimuth=jap24; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; azimuth=ind24; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; azimuth=aus24; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; azimuth=afr24; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (encoder.timeRight!=0){azimuth++; beep(); single=0;                                    //включаем счётчик вращения энкодера вправо
  if (azimuth>24){azimuth=0;} encoder.timeRight=0;}                                         //ограничиваем значение энкодера 24 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){azimuth--; beep(); single=0;                                     //включаем счётчик вращения энкодера влево
  if (azimuth<0){azimuth=24;} encoder.timeLeft=0;}                                          //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; can24=azimuth; break;                                                    //если "Position=1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; nam24=azimuth; break;                                                    //если "Position=2" -------------------------------------------- Северной Америки
    case 3: y=114; lam24=azimuth; break;                                                    //если "Position=3" -------------------------------------------- Латинской Америки
    case 4: y=147; eur24=azimuth; break;                                                    //если "Position=4" -------------------------------------------- Европы
    case 5: y=180; jap24=azimuth; break;                                                    //если "Position=5" -------------------------------------------- Японии
    case 6: y=213; ind24=azimuth; break;                                                    //если "Position=6" -------------------------------------------- Индии
    case 7: y=246; aus24=azimuth; break;                                                    //если "Position=7" -------------------------------------------- Австралии
    case 8: y=279; afr24=azimuth; break;}                                                   //если "Position=8" -------------------------------------------- Африки
  if (single==0){single++;                                                                  //включаем "single" счётчиком чтобы вывести координаты один раз
    dtostrf(azimuth*15,len,0,buf);                                                          //конвертируем символьный массив вывода данных
    tft.setTextPadding(46); tft.drawCentreString(buf,430,y,4);                              //выводим значение азимута
    tft.setTextPadding(0); tft.drawString(".",455,y-13,1);}                                 //с символом "°" в конце
  if (butt1.isSingle()){beep(); single=0; azimuth=25;}                                      //двойным кликом выставляем "single=0" и "azimuth=25"
}   EEPROM.update(26,can24); EEPROM.update(27,nam24);                                       //сохраняем полученные значения в ячейки EEPROM
    EEPROM.update(28,lam24); EEPROM.update(29,eur24);                                       //---------------------------------------------
    EEPROM.update(30,jap24); EEPROM.update(31,ind24);                                       //---------------------------------------------
    EEPROM.update(32,aus24); EEPROM.update(33,afr24);                                       //---------------------------------------------
    submenu=0; goto M2;}                                                                    //сбрасываем "submenu" в 0 и выходим из режима коррекции по метке М2
  if (number==16){                                                                          //если количество импульсов 16 
while (azimuth<17){                                                                         //находимся в цикле пока azimuth<17
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; azimuth=can16; break;                                                    //если "Position==1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; azimuth=nam16; break;                                                    //если "Position==2" -------------------------------------------- Северной Америки
    case 3: y=114; azimuth=lam16; break;                                                    //если "Position==3" -------------------------------------------- Латинской Америки
    case 4: y=147; azimuth=eur16; break;                                                    //если "Position==4" -------------------------------------------- Европы
    case 5: y=180; azimuth=jap16; break;                                                    //если "Position==5" -------------------------------------------- Японии
    case 6: y=213; azimuth=ind16; break;                                                    //если "Position==6" -------------------------------------------- Индии
    case 7: y=246; azimuth=aus16; break;                                                    //если "Position==7" -------------------------------------------- Австралии
    case 8: y=279; azimuth=afr16; break;}                                                   //если "Position==8" -------------------------------------------- Африки
  if (encoder.timeRight!=0){azimuth++; beep(); single=0;                                    //включаем счётчик вращения энкодера вправо
  if (azimuth>16){azimuth=0;} encoder.timeRight=0;}                                         //ограничиваем значение энкодера 16 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){azimuth--; beep(); single=0;                                     //включаем счётчик вращения энкодера влево
  if (azimuth<0){azimuth=16;} encoder.timeLeft=0;}                                          //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(Position){                                                                         //функция выбора координаты "y" до коррекции
    case 1: y= 48; can16=azimuth; break;                                                    //если "Position==1" определяем координату "y" для вывода азимута Канады
    case 2: y= 81; nam16=azimuth; break;                                                    //если "Position==2" -------------------------------------------- Северной Америки
    case 3: y=114; lam16=azimuth; break;                                                    //если "Position==3" -------------------------------------------- Латинской Америки
    case 4: y=147; eur16=azimuth; break;                                                    //если "Position==4" -------------------------------------------- Европы
    case 5: y=180; jap16=azimuth; break;                                                    //если "Position==5" -------------------------------------------- Японии
    case 6: y=213; ind16=azimuth; break;                                                    //если "Position==6" -------------------------------------------- Индии
    case 7: y=246; aus16=azimuth; break;                                                    //если "Position==7" -------------------------------------------- Австралии
    case 8: y=279; afr16=azimuth; break;}                                                   //если "Position==8" -------------------------------------------- Африки
  if (single==0){single++;                                                                  //включаем "single" счётчиком чтобы вывести координаты один раз
    dtostrf(azimuth*22.5,len,0,buf);                                                        //конвертируем символьный массив вывода данных
    tft.setTextPadding(46); tft.drawCentreString(buf,430,y,4);                              //выводим значение азимута
    tft.setTextPadding(0); tft.drawString(".",455,y-13,1);}                                 //с символом "°" в конце
  if (butt1.isSingle()){beep(); single=0; azimuth=17;}                                      //двойным кликом выставляем "single=0" и "azimuth=17"
}   EEPROM.update(34,can16); EEPROM.update(35,nam16);                                       //сохраняем полученные значения в ячейки EEPROM
    EEPROM.update(36,lam16); EEPROM.update(37,eur16);                                       //---------------------------------------------
    EEPROM.update(38,jap16); EEPROM.update(39,ind16);                                       //---------------------------------------------
    EEPROM.update(40,aus16); EEPROM.update(41,afr16);                                       //---------------------------------------------
    submenu=0; goto M2;}                                                                    //сбрасываем "submenu" в 0 и выходим из режима коррекции по метке М2
}//************************************ Выход из коррекции азимутов предустановок *******************************************************************
  for (int i=1; i<9; i++){                                                                  //включаем цикл вывода на экран значений азимутов
    char buf[5]; byte len=4;                                                                //формируем буфер для вывода символьного массива
  if (number==360){                                                                         //если количество импульсов 360
  switch(i){
    case 1: pos=can; y= 48; tft.drawCentreString("azimuth",365,50,1); break;                //читаем ячейки №42,43 приравниваем её к переменной "pos", определяем координату по "y"
    case 2: pos=nam; y= 81; tft.drawCentreString("azimuth",365,83,1); break;                //читаем ячейки №44,45 ---------------------------------------------------------------
    case 3: pos=lam; y=114; tft.drawCentreString("azimuth",365,116,1); break;               //читаем ячейки №46,47 ---------------------------------------------------------------
    case 4: pos=eur; y=147; tft.drawCentreString("azimuth",365,149,1); break;               //читаем ячейки №48,49 ---------------------------------------------------------------
    case 5: pos=jap; y=180; tft.drawCentreString("azimuth",365,182,1); break;               //читаем ячейки №50,51 ---------------------------------------------------------------
    case 6: pos=ind; y=213; tft.drawCentreString("azimuth",365,215,1); break;               //читаем ячейки №52,53 ---------------------------------------------------------------
    case 7: pos=aus; y=246; tft.drawCentreString("azimuth",365,248,1); break;               //читаем ячейки №54,55 ---------------------------------------------------------------
    case 8: pos=afr; y=279; tft.drawCentreString("azimuth",365,281,1); break;}              //читаем ячейки №56,57 ---------------------------------------------------------------
    dtostrf(pos,len,0,buf); tft.drawCentreString(buf,430,y,4);}                             //конвертируем символьный массив вывода данных значения азимута
  if (number==72){                                                                          //если количество импульсов 72
  switch(i){
    case 1: pos=can72; y= 48; tft.drawCentreString("azimuth",365,50,1); break;              //читаем ячейку №58 приравниваем её к переменной "pos", определяем координату по "y"
    case 2: pos=nam72; y= 81; tft.drawCentreString("azimuth",365,83,1); break;              //читаем ячейку №59 ---------------------------------------------------------------
    case 3: pos=lam72; y=114; tft.drawCentreString("azimuth",365,116,1); break;             //читаем ячейку №60 ---------------------------------------------------------------
    case 4: pos=eur72; y=147; tft.drawCentreString("azimuth",365,149,1); break;             //читаем ячейку №61 ---------------------------------------------------------------
    case 5: pos=jap72; y=180; tft.drawCentreString("azimuth",365,182,1); break;             //читаем ячейку №62 ---------------------------------------------------------------
    case 6: pos=ind72; y=213; tft.drawCentreString("azimuth",365,215,1); break;             //читаем ячейку №63 --------------------------------------------------------------
    case 7: pos=aus72; y=246; tft.drawCentreString("azimuth",365,248,1); break;             //читаем ячейку №64 --------------------------------------------------------------
    case 8: pos=afr72; y=279; tft.drawCentreString("azimuth",365,281,1); break;}            //читаем ячейку №65 --------------------------------------------------------------
    dtostrf(pos*5,len,0,buf); tft.drawCentreString(buf,430,y,4);}                           //конвертируем символьный массив вывода данных значения азимута  
  if (number==36){                                                                          //если количество импульсов 36
  switch(i){
    case 1: pos=can36; y= 48; tft.drawCentreString("azimuth",365,50,1); break;              //читаем ячейку №18 приравниваем её к переменной "pos", определяем координату по "y"
    case 2: pos=nam36; y= 81; tft.drawCentreString("azimuth",365,83,1); break;              //читаем ячейку №19 ---------------------------------------------------------------
    case 3: pos=lam36; y=114; tft.drawCentreString("azimuth",365,116,1); break;             //читаем ячейку №20 ---------------------------------------------------------------
    case 4: pos=eur36; y=147; tft.drawCentreString("azimuth",365,149,1); break;             //читаем ячейку №21 ---------------------------------------------------------------
    case 5: pos=jap36; y=180; tft.drawCentreString("azimuth",365,182,1); break;             //читаем ячейку №22 ---------------------------------------------------------------
    case 6: pos=ind36; y=213; tft.drawCentreString("azimuth",365,215,1); break;             //читаем ячейку №23 ---------------------------------------------------------------
    case 7: pos=aus36; y=246; tft.drawCentreString("azimuth",365,248,1); break;             //читаем ячейку №24 ---------------------------------------------------------------
    case 8: pos=afr36; y=279; tft.drawCentreString("azimuth",365,281,1); break;}            //читаем ячейку №25 ---------------------------------------------------------------
    dtostrf(pos*10,len,0,buf); tft.drawCentreString(buf,430,y,4);}                          //конвертируем символьный массив вывода данных значения азимута
  if (number==24){                                                                          //если количество импульсов 24
  switch(i){
    case 1: pos=can24; y= 48; tft.drawCentreString("azimuth",365,50,1); break;              //читаем ячейку №26 приравниваем её к переменной "pos", определяем координату по "y"
    case 2: pos=nam24; y= 81; tft.drawCentreString("azimuth",365,83,1); break;              //читаем ячейку №27 ---------------------------------------------------------------
    case 3: pos=lam24; y=114; tft.drawCentreString("azimuth",365,116,1); break;             //читаем ячейку №28 ---------------------------------------------------------------
    case 4: pos=eur24; y=147; tft.drawCentreString("azimuth",365,149,1); break;             //читаем ячейку №29 ---------------------------------------------------------------
    case 5: pos=jap24; y=180; tft.drawCentreString("azimuth",365,182,1); break;             //читаем ячейку №30 ---------------------------------------------------------------
    case 6: pos=ind24; y=213; tft.drawCentreString("azimuth",365,215,1); break;             //читаем ячейку №31 ---------------------------------------------------------------
    case 7: pos=aus24; y=246; tft.drawCentreString("azimuth",365,248,1); break;             //читаем ячейку №32 ---------------------------------------------------------------
    case 8: pos=afr24; y=279; tft.drawCentreString("azimuth",365,281,1); break;}            //читаем ячейку №33 ---------------------------------------------------------------
    dtostrf(pos*15,len,0,buf); tft.drawCentreString(buf,430,y,4);}                          //конвертируем символьный массив вывода данных значения азимута
  if (number==16){                                                                          //если количество импульсов 16
  switch(i){
    case 1: pos=can16; y= 48; tft.drawCentreString("azimuth",365,50,1); break;              //читаем ячейку №34 приравниваем её к переменной "pos", определяем координату по "y"
    case 2: pos=nam16; y= 81; tft.drawCentreString("azimuth",365,83,1); break;              //читаем ячейку №35 ---------------------------------------------------------------
    case 3: pos=lam16; y=114; tft.drawCentreString("azimuth",365,116,1); break;             //читаем ячейку №36 ---------------------------------------------------------------
    case 4: pos=eur16; y=147; tft.drawCentreString("azimuth",365,149,1); break;             //читаем ячейку №37 ---------------------------------------------------------------
    case 5: pos=jap16; y=180; tft.drawCentreString("azimuth",365,182,1); break;             //читаем ячейку №38 ---------------------------------------------------------------
    case 6: pos=ind16; y=213; tft.drawCentreString("azimuth",365,215,1); break;             //читаем ячейку №39 ---------------------------------------------------------------
    case 7: pos=aus16; y=246; tft.drawCentreString("azimuth",365,248,1); break;             //читаем ячейку №40 ---------------------------------------------------------------
    case 8: pos=afr16; y=279; tft.drawCentreString("azimuth",365,281,1); break;}            //читаем ячейку №41 ---------------------------------------------------------------
    dtostrf(pos*22.5,len,0,buf); tft.drawCentreString(buf,430,y,4);}                        //конвертируем символьный массив вывода данных значения азимута
    tft.drawString(".",455,y-13,1);}                                                        //выводим символ "°"
M2: while (Position<9){                                                                     //находимся в режиме предустановок пока "Position<9"
    butt1.tick();                                                                           //обязательная функция отработки. Должна постоянно опрашиваться
    char buf[5]; byte len=4;                                                                //формируем буфер для вывода символьного массива
  if (encoder.timeRight!=0){Position++; beep();                                             //включаем счётчик вращения энкодера вправо
  if (Position>8){Position=1;} encoder.timeRight=0;}                                        //ограничиваем значение энкодера 8 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){Position--; beep();                                              //включаем счётчик вращения энкодера влево
  if (Position<1){Position=8;} encoder.timeLeft=0;}                                         //ограничиваем значение энкодера 0 импульсов, работает по кольцу
  switch(Position){                                                                         //выбор предустановки
  case 1: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,279-13,1);                    //иначе выводим символ "°" и
    tft.drawString("8. Africa",25,281,1);                                                   //выводим надпись "8. Africa"
    tft.drawCentreString("azimuth",365,281,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(afr,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Africa" зелёным цветом
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(afr72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута  
  if (number==36){dtostrf(afr36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(afr24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(afr16*22.5,len,0,buf);                                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,81-13,1);                           //иначе выводим символ "°" и
    tft.drawString("2. Northern America",25,83,1);                                          //выводим надпись "2. Northern America"
    tft.drawCentreString("azimuth",365,83,1);                                               //надпись "azimuth"
  if (number==360){dtostrf(nam,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Northern America" зелёным цветом
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==72){dtostrf(nam72*5,len,0,buf);                                               //если количество импульсов 72 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==36){dtostrf(nam36*10,len,0,buf);                                              //если количество импульсов 36 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==24){dtostrf(nam24*15,len,0,buf);                                              //если количество импульсов 24 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==16){dtostrf(nam16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("1. Canada",25,50,1);                         //выбираем красный цвет, выводим надпись "1. Canada"
    tft.drawCentreString("azimuth",365,50,1);                                               //выводим надпись "azimuth"
    tft.drawString(".",455,48-13,1);                                                        //и символ "°"
  if (number==360){pencoder=can; dtostrf(can,len,0,buf);                                    //если количество импульсов 360 значение азимута "Canada" красным цветом
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==72){pencoder=can72; dtostrf(can72*5,len,0,buf);                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==36){pencoder=can36; dtostrf(can36*10,len,0,buf);                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==24){pencoder=can24; dtostrf(can24*15,len,0,buf);                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==16){pencoder=can16; dtostrf(can16*22.5,len,0,buf);                            //если количество импульсов 16 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);} break;                                             //выводим значение азимута
  case 2: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,48-13,1);                     //иначе выводим символ "°" и
    tft.drawString("1. Canada",25,50,1);                                                    //выводим надпись "1. Canada"
    tft.drawCentreString("azimuth",365,50,1);                                               //надпись "azimuth"
  if (number==360){dtostrf(can,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Canada" зелёным цветом
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==72){dtostrf(can72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==36){dtostrf(can36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==24){dtostrf(can24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==16){dtostrf(can16*22.5,len,0,buf);                                            //если количество импульсов 16 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,114-13,1);                          //иначе выводим символ "°" и
    tft.drawString("3. Latin America",25,116,1);                                            //выводим надпись "3. Latin America"
    tft.drawCentreString("azimuth",365,116,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(lam,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Latin America" зелёным цветом
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(lam72*5,len,0,buf);                                               //если количество импульсов 72 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(lam36*10,len,0,buf);                                              //если количество импульсов 36 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(lam24*15,len,0,buf);                                              //если количество импульсов 24 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(lam16*22.5,len,0,buf);                                            //если количество импульсов 16 -----------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED);tft.drawString("2. Northern America",25,83,1);                //выбираем красный цвет, выводим надпись "2. Northern America"
    tft.drawCentreString("azimuth",365,83,1);                                               //выводим надпись "azimuth"
    tft.drawString(".",455,81-13,1);                                                        //и символ "°"
  if (number==360){pencoder=nam; dtostrf(nam,len,0,buf);                                    //если количество импульсов 360 значение азимута "Northern America" красным цветом
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==72){pencoder=nam72; dtostrf(nam72*5,len,0,buf);                               //если количество импульсов 72 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==36){pencoder=nam36; dtostrf(nam36*10,len,0,buf);                              //если количество импульсов 36 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==24){pencoder=nam24; dtostrf(nam24*15,len,0,buf);                              //если количество импульсов 24 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==16){pencoder=nam16; dtostrf(nam16*22.5,len,0,buf);                            //если количество импульсов 16 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);} break;                                             //выводим значение азимута
  case 3: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,81-13,1);                     //иначе выводим символ "°" и
    tft.drawString("2. Northern America",25,83,1);                                          //выводим надпись "2. Northern America"
    tft.drawCentreString("azimuth",365,83,1);                                               //надпись "azimuth"
  if (number==360){dtostrf(nam,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Northern America" зелёным цветом
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==72){dtostrf(nam72*5,len,0,buf);                                               //если количество импульсов 72 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==36){dtostrf(nam36*10,len,0,buf);                                              //если количество импульсов 36 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==24){dtostrf(nam24*15,len,0,buf);                                              //если количество импульсов 24 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
  if (number==16){dtostrf(nam16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------------------
    tft.drawCentreString(buf,430,81,4);}                                                    //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,147-13,1);                          //иначе выводим символ "°" и
    tft.drawString("4. Europe",25,149,1);                                                   //выводим надпись "4. Europe"
    tft.drawCentreString("azimuth",365,149,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(eur,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Europe" зелёным цветом
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(eur72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(eur36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(eur24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(eur16*22.5,len,0,buf);                                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("3. Latin America",25,116,1);                 //выбираем красный цвет, выводим надпись "3. Latin America"
    tft.drawCentreString("azimuth",365,116,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,114-13,1);                                                       //и символ "°"
  if (number==360){pencoder=lam; dtostrf(lam,len,0,buf);                                    //если количество импульсов 360 значение азимута "Latin America" красным цветом
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=lam72; dtostrf(lam72*5,len,0,buf);                               //если количество импульсов 72 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=lam36; dtostrf(lam36*10,len,0,buf);                              //если количество импульсов 36 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=lam24; dtostrf(lam24*15,len,0,buf);                              //если количество импульсов 24 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=lam16; dtostrf(lam16*22.5,len,0,buf);                            //если количество импульсов 16 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);} break;                                            //выводим значение азимута
  case 4: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,114-13,1);                    //иначе выводим символ "°" и
    tft.drawString("3. Latin America",25,116,1);                                            //выводим надпись "3. Latin America"
    tft.drawCentreString("azimuth",365,116,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(lam,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Latin America" зелёным цветом
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(lam72*5,len,0,buf);                                               //если количество импульсов 72 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(lam36*10,len,0,buf);                                              //если количество импульсов 36 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(lam24*15,len,0,buf);                                              //если количество импульсов 24 ------------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(lam16*22.5,len,0,buf);                                            //если количество импульсов 16 -----------------------------------------------
    tft.drawCentreString(buf,430,114,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,180-13,1);                          //иначе выводим символ "°" и
    tft.drawString("5. Japan",25,182,1);                                                    //выводим надпись "5. Japan"
    tft.drawCentreString("azimuth",365,182,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(jap,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Japan" зелёным цветом
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(jap72*5,len,0,buf);                                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(jap36*10,len,0,buf);                                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(jap24*15,len,0,buf);                                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(jap16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("4. Europe",25,149,1);                        //выбираем красный цвет, выводим надпись "4. Europe"
    tft.drawCentreString("azimuth",365,149,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,147-13,1);                                                       //и символ "°"
  if (number==360){pencoder=eur; dtostrf(eur,len,0,buf);                                    //если количество импульсов 360 значение азимута "Europe" красным цветом
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=eur72; dtostrf(eur72*5,len,0,buf);                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=eur36; dtostrf(eur36*10,len,0,buf);                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=eur24; dtostrf(eur24*15,len,0,buf);                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=eur16; dtostrf(eur16*22.5,len,0,buf);                            //если количество импульсов 16 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);} break;                                            //выводим значение азимута
  case 5: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,147-13,1);                    //иначе выводим символ "°" и
    tft.drawString("4. Europe",25,149,1);                                                   //выводим надпись "4. Europe"
    tft.drawCentreString("azimuth",365,149,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(eur,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Europe" зелёным цветом
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(eur72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(eur36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(eur24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(eur16*22.5,len,0,buf);                                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,147,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,213-13,1);                          //иначе выводим символ "°" и
    tft.drawString("6. India",25,215,1);                                                    //выводим надпись "6. India"
    tft.drawCentreString("azimuth",365,215,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(ind,len,0,buf);                                                  //если количество импульсов 360 значение азимута "India" зелёным цветом
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(ind72*5,len,0,buf);                                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(ind36*10,len,0,buf);                                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(ind24*15,len,0,buf);                                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(ind16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("5. Japan",25,182,1);                         //выбираем красный цвет, выводим надпись "5. Japan"
    tft.drawCentreString("azimuth",365,182,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,180-13,1);                                                       //и символ "°"
  if (number==360){pencoder=jap; dtostrf(jap,len,0,buf);                                    //если количество импульсов 360 значение азимута "Japan" красным цветом
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=jap72; dtostrf(jap72*5,len,0,buf);                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=jap36; dtostrf(jap36*10,len,0,buf);                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=jap24; dtostrf(jap24*15,len,0,buf);                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=jap16; dtostrf(jap16*22.5,len,0,buf);                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);} break;                                            //выводим значение азимута
  case 6: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,180-13,1);                    //иначе выводим символ "°" и
    tft.drawString("5. Japan",25,182,1);                                                    //выводим надпись "5. Japan"
    tft.drawCentreString("azimuth",365,182,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(jap,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Japan" зелёным цветом
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(jap72*5,len,0,buf);                                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(jap36*10,len,0,buf);                                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(jap24*15,len,0,buf);                                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(jap16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------
    tft.drawCentreString(buf,430,180,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,246-13,1);                          //иначе выводим символ "°" и
    tft.drawString("7. Australia",25,248,1);                                                //выводим надпись "7. Australia"
    tft.drawCentreString("azimuth",365,248,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(aus,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Australia" зелёным цветом
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(aus72*5,len,0,buf);                                               //если количество импульсов 72 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(aus36*10,len,0,buf);                                              //если количество импульсов 36 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(aus24*15,len,0,buf);                                              //если количество импульсов 24 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(aus16*22.5,len,0,buf);                                            //если количество импульсов 16 -------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("6. India",25,215,1);                         //выбираем красный цвет, выводим надпись "6. India"
    tft.drawCentreString("azimuth",365,215,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,213-13,1);                                                       //и символ "°"
  if (number==360){pencoder=ind; dtostrf(ind,len,0,buf);                                    //если количество импульсов 360 значение азимута "India" красным цветом
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=ind72; dtostrf(ind72*5,len,0,buf);                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=ind36; dtostrf(ind36*10,len,0,buf);                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=ind24; dtostrf(ind24*15,len,0,buf);                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=ind16; dtostrf(ind16*22.5,len,0,buf);                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);} break;                                            //выводим значение азимута
  case 7: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,213-13,1);                    //иначе выводим символ "°" и
    tft.drawString("6. India",25,215,1);                                                    //выводим надпись "6. India"
    tft.drawCentreString("azimuth",365,215,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(ind,len,0,buf);                                                  //если количество импульсов 360 значение азимута "India" зелёным цветом
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(ind72*5,len,0,buf);                                               //если количество импульсов 72 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(ind36*10,len,0,buf);                                              //если количество импульсов 36 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(ind24*15,len,0,buf);                                              //если количество импульсов 24 ----------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(ind16*22.5,len,0,buf);                                            //если количество импульсов 16 ---------------------------------------
    tft.drawCentreString(buf,430,213,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,279-13,1);                          //иначе выводим символ "°" и
    tft.drawString("8. Africa",25,281,1);                                                   //выводим надпись "8. Africa"
    tft.drawCentreString("azimuth",365,281,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(afr,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Africa" зелёным цветом
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(afr72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(afr36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(afr24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(afr16*22.5,len,0,buf);                                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_RED);tft.drawString("7. Australia",25,248,1);                      //выбираем красный цвет, выводим надпись "7. Australia"
    tft.drawCentreString("azimuth",365,248,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,246-13,1);                                                       //и символ "°"
  if (number==360){pencoder=aus; dtostrf(aus,len,0,buf);                                    //если количество импульсов 360 значение азимута "Australia" красным цветом
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=aus72; dtostrf(aus72*5,len,0,buf);                               //если количество импульсов 72 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=aus36; dtostrf(aus36*10,len,0,buf);                              //если количество импульсов 36 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=aus24; dtostrf(aus24*15,len,0,buf);                              //если количество импульсов 24 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=aus16; dtostrf(aus16*22.5,len,0,buf);                            //если количество импульсов 16 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);} break;                                            //выводим значение азимута
  case 8: tft.setTextColor(TFT_GREEN); tft.drawString(".",455,246-13,1);                    //иначе выводим символ "°" и
    tft.drawString("7. Australia",25,248,1);                                                //выводим надпись "7. Australia"
    tft.drawCentreString("azimuth",365,248,1);                                              //надпись "azimuth"
  if (number==360){dtostrf(aus,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Australia" зелёным цветом
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==72){dtostrf(aus72*5,len,0,buf);                                               //если количество импульсов 72 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==36){dtostrf(aus36*10,len,0,buf);                                              //если количество импульсов 36 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==24){dtostrf(aus24*15,len,0,buf);                                              //если количество импульсов 24 --------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
  if (number==16){dtostrf(aus16*22.5,len,0,buf);                                            //если количество импульсов 16 -------------------------------------------
    tft.drawCentreString(buf,430,246,4);}                                                   //выводим значение азимута
    tft.setTextColor(TFT_GREEN); tft.drawString(".",455,48-13,1);                           //иначе выводим символ "°" и
    tft.drawString("1. Canada",25,50,1);                                                    //выводим надпись "1. Canada"
    tft.drawCentreString("azimuth",365,50,1);                                               //надпись "azimuth"
  if (number==360){dtostrf(can,len,0,buf);                                                  //если количество импульсов 360 значение азимута "Canada" зелёным цветом
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==72){dtostrf(can72*5,len,0,buf);                                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==36){dtostrf(can36*10,len,0,buf);                                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==24){dtostrf(can24*15,len,0,buf);                                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
  if (number==16){dtostrf(can16*22.5,len,0,buf);                                            //если количество импульсов 16 ----------------------------------------
    tft.drawCentreString(buf,430,48,4);}                                                    //выводим значение азимута
    tft.setTextColor(TFT_RED); tft.drawString("8. Africa",25,281,1);                        //выбираем красный цвет, выводим надпись "8. Africa"
    tft.drawCentreString("azimuth",365,281,1);                                              //выводим надпись "azimuth"
    tft.drawString(".",455,279-13,1);                                                       //и символ "°"
  if (number==360){pencoder=afr; dtostrf(afr,len,0,buf);                                    //если количество импульсов 360 значение азимута "Africa" красным цветом
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==72){pencoder=afr72; dtostrf(afr72*5,len,0,buf);                               //если количество импульсов 72 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==36){pencoder=afr36; dtostrf(afr36*10,len,0,buf);                              //если количество импульсов 36 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==24){pencoder=afr24; dtostrf(afr24*15,len,0,buf);                              //если количество импульсов 24 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);}                                                   //выводим значение азимута
  if (number==16){pencoder=afr16; dtostrf(afr16*22.5,len,0,buf);                            //если количество импульсов 16 -----------------------------------------
    tft.drawCentreString(buf,430,279,4);} break;}                                           //выводим значение азимута
  if (butt1.isSingle()){beep();                                                             //одинарным тиком
  if (Position==0){goto M3;}                                                                //если выходим без выбора предустановки, переходим по метке М3 без сохранения
  if (Position!=0){Position=9;}}                                                            //если выходим после выбора предустановки выставляем "Position=9"
  if (butt1.isDouble()){beep(); azimuth=0; single=0; submenu=1; goto M1;}                   //двойным тиком сбрасываем "azimuth" в 0, и переходим по метку М1 для коррекции азимута
  if (butt1.isTriple()){beep(); goto M3;}                                                   //если выбор был сделан ошибочно то тройным тиком выходим без сохранения
} Pencoder=pencoder; EEPROM.update(5,highByte(Pencoder));EEPROM.update(6,lowByte(Pencoder));//сохраняем в ячейки №5 и №6 EEPROM значение предустановки
    flag_Ememory=1; flag_SEmemory=1; singlePoint=0;                                         //выставляем флаги
M3: SetStep=1; flag_Position=1; flagtemp=false;                                             //"SetStep"  и "flag_Position" выставляем в 1 для индикации предустановок и "Setting"
    preparing_the_screen();}                                                                //выходим из предустановок и вызываем подпрограмму подготовки экрана
void thermometer(){//************************************************ Термометр *********************************************************************
    Wire.beginTransmission(104);                                                            //посылаем запрос по адресу 104 I2C
    Wire.write(0x11);                                                                       //запрос данных в линию I2C
    Wire.endTransmission();                                                                 //останавливаем передачу данных
    Wire.requestFrom(104,2);                                                                //получаем данные с адреса 104 I2C
    tMSB=Wire.read();                                                                       //читаем старший байт
    tLSB=Wire.read();                                                                       //читаем младший байт
    temp3231=(tMSB&B01111111);                                                              //конвертируем старший байт
    temp3231+=((tLSB>>6)*0.25);}                                                            //конвертируем младший байт, получаем температуру
void realtime(){//********************************************* Часы реального времени **************************************************************
  if (nomodule==0){                                                                         //если модуль часов подключен
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
M1: tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //выбираем шрифт и цвет текста
    tft.drawCentreString("Single click to exit",240,205,1);                                 //выводим надпись "Single click to exit"
    tft.drawCentreString("Double click to set the clock",240,240,1);                        //выводим надпись "Double click to set the clock"
    tft.drawCentreString("Triple click alarm setting",240,275,1);                           //выводим надпись "Triple click alarm setting"
  for(int i=0; i<2; i++){                                                                   //запускаем цикл
    tft.drawRoundRect(46+i,31+i,71-i*2,57-i*2,4-i,TFT_RED);}                                //рисуем наружную окантовку
    tft.fillRoundRect(48,33,67,53,2,TFT_YELLOW);                                            //заливаем её фоном
    symbol_bell_clock();                                                                    //выводим символ будильника в часах
    alarmonoff=EEPROM.read(194);                                                            //читаем состояние будильника
    tft.setFreeFont(FSBI12); tft.setTextColor(TFT_RED);                                     //выбираем шрифт и цвет текста
  if (alarmonoff==0){tft.drawCentreString("OFF",80,66,1);}                                  //если будильник выключен выводим надпись "OFF"
  for(int i=0; i<2; i++){                                                                   //запускаем цикл
    tft.drawRoundRect(46+i,90+i,71-i*2,49-i*2,4-i,TFT_RED);}                                //рисуем наружную окантовку
    tft.fillRoundRect(48,92,67,45,2,TFT_YELLOW);                                            //заливаем её фоном
    tft.drawCentreString("Temp",80,96,1);                                                   //выводим надпись "Temp"
  if (alarmonoff==1){                                                                       //если будильник включен выводим данные будильника в часах
    hhalarm=EEPROM.read(191);                                                               //читаем значение часов для будильника
    mmalarm=EEPROM.read(192);                                                               //читаем значение минут для будильника
    ssalarm=EEPROM.read(193);                                                               //читаем значение секунд для будильника
    int xpos_clock=54;                                                                      //начальная координата по х
    int ypos_clock=66;                                                                      //начальная координата по y
    int xmin_clock=0;                                                                       //координата по x для вывода минут
  if (hhalarm<10) xpos_clock+=tft.drawChar('0',xpos_clock,ypos_clock+15,1);                 //если показания часов меньше 10 дорисовываем незначащий ноль
    xpos_clock+=tft.drawNumber(hhalarm,xpos_clock,ypos_clock,1);                            //выводим значение часов
    xmin_clock=xpos_clock;                                                                  //приравниваем координату x вывода секунд к начальной координате по x
    xpos_clock+=tft.drawChar(':',xmin_clock,ypos_clock-4,4);                                //рисуем минутное двоеточие
  if (mmalarm<10) xpos_clock+=tft.drawChar('0',xpos_clock,ypos_clock+15,1);                 //если показания минут меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(mmalarm,xpos_clock,ypos_clock,1);}                                       //выводим значение минут
while (place<8){                                                                            //находимся в цикле пока "place<1"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isSingle()){beep(); break;}                                                     //одинарным кликом выходим из цикла
  if (butt1.isDouble()){beep(); setclock=1; goto M2;}                                       //двойным кликом выставляем "setclock" в 1 и переходим по метке М2 в режим коррекции часов
  if (butt1.isTriple()){beep(); setalarm=1; singlealarm=0; goto M3;}                        //тройным кликом выставляем "setalarm" в 1 и переходим по метке М3 в установку будильника
    tmElements_t tm;                                                                        //переменная установки даты и времени
    RTC.read(tm);                                                                           //переменная чтения даты и времени
    thermometer();                                                                          //вызываем подпрограмму измерения температуры
  if (TEMP2!=temp3231){flagtemp=false;};                                                    //если температура отличается от "TEMP2" выставляем "flagtemp" в false
  if (!flagtemp){flagtemp=true; TEMP2=temp3231;                                             //приравниваем "TEMP2" к температуре и выставляем "flagtemp" в true
    tft.setFreeFont(FSBI12); tft.setTextColor(TFT_RED,TFT_YELLOW);                          //выбираем шрифт и цвет текста
    char bufT[5]; byte lenT=4; dtostrf(TEMP2,-lenT,1,bufT);                                 //конвертируем символьный массив
    bufT[lenT]='C'; bufT[lenT+1]=0;                                                         //вывода данных температуры
    tft.drawCentreString(bufT,80,116,1);}                                                   //раз в минуту выводим значение температуры с добавлением "С"
  if ((hhalarm==tm.Hour)&&(mmalarm==tm.Minute)&&(ssalarm==tm.Second)&&                      //если установленные для будильника значения часов, минут и секунд совпадают с текущими
  (alarmonoff==1)&&(singlealarm==0)){                                                       //и будильник разрешен
    singlealarm++;                                                                          //включаем "singlealarm" счётчиком для однократного звучания будильника
  if (select==0){elis(); alarmonoff=0; EEPROM.update(194,alarmonoff);}                      //если "select==0" однократно звучит рингтон "К Элизе"
  if (select==1){polones(); alarmonoff=0; EEPROM.update(194,alarmonoff);}                   //если "select==1" однократно звучит рингтон "Полонез Огинского"
    tft.fillRoundRect(48,66,67,17,4,TFT_YELLOW);                                            //затираем показания будильника
    tft.setFreeFont(FSBI12); tft.setTextColor(TFT_RED);                                     //выбираем шрифт и цвет текста
    tft.drawCentreString("OFF",80,66,1);}                                                   //выводим надпись "OFF"
    int hh=tm.Hour;                                                                         //выводим часы
    int mm=tm.Minute;                                                                       //выводим минуты
    int ss=tm.Second;                                                                       //выводим секунды
    int dy=tm.Wday;                                                                         //выводим день недели
    int da=tm.Day;                                                                          //выводим число
    int mo=tm.Month;                                                                        //выводим месяц
    int ya=tm.Year;                                                                         //выводим год
    int xpos=137;                                                                           //начальная координата по х для вывода часов
    int ypos=35;                                                                            //начальная координата по y для вывода часов
    int xsecs=0;                                                                            //координата по x для вывода секунд
    int xpos1=100;                                                                          //начальная координата по х для вывода даты
    int ypos1=145;                                                                          //начальная координата по y для вывода даты
    int yYear=ypos1;                                                                        //координата по y для вывода года
    int xYear=0;                                                                            //координата по x для вывода года
    tft.setTextColor(bordercolor,TFT_GREY40);                                               //выставляем выбранный цвет часов
    tft.setTextPadding(20);                                                                 //включаем обновление подложки шрифта
  if (hh<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания часов меньше 10 дорисовываем незначащий ноль
    xpos+=tft.drawNumber(hh,xpos,ypos,7);                                                   //выводим значение часов
    xpos+=tft.drawChar(':',xpos,ypos,7);                                                    //рисуем часовое и минутное двоеточие
  if (mm<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания минут меньше 10 дорисовываем незначащий ноль
    xpos+=tft.drawNumber(mm,xpos,ypos,7);                                                   //выводим значение минут
    xsecs=xpos;                                                                             //приравниваем координату x вывода секунд к начальной координате по x
    xpos+=tft.drawChar(':',xsecs,ypos,7);                                                   //рисуем секундное двоеточие
  if (ss<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания секунд меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(ss,xpos,ypos,7);                                                         //выводим значение секунд
  if (da<10)xpos1+=tft.drawChar('0',xpos1,ypos1,7);                                         //если показания числа меньше 10 дорисовываем незначащий ноль
    xpos1+=tft.drawNumber(da,xpos1,ypos1,7);                                                //выводим значение числа
    xpos1+=tft.drawChar(' ',xpos1,ypos1,7);                                                 //формируем пробел между числом и месяцем
  if (mo<10)xpos1+=tft.drawChar('0',xpos1,ypos1,7);                                         //если показания месяца меньше 10 дорисовываем незначащий ноль
    xpos1+=tft.drawNumber(mo,xpos1,ypos1,7);                                                //выводим значение месяца
    xYear=xpos1;                                                                            //приравниваем координату x вывода года к координате вывода даты
    xpos1+=tft.drawChar(' ',xYear,yYear,7);                                                 //формируем пробел между месяцем и годом
    tft.drawNumber((int)ya+1970,xpos1,yYear,7);                                             //выводим значение года
    tft.setFreeFont(FSBI24); tft.setTextColor(bordercolor);                                 //выбираем шрифт и цвет вывода дня недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawCentreString("Monday",240,95,1);    break;                              //выводим понедельник
    case 2: tft.drawCentreString("Tuesday",240,95,1);   break;                              //выводим вторник
    case 3: tft.drawCentreString("Wednesday",240,95,1); break;                              //выводим среда
    case 4: tft.drawCentreString("Thursday",240,95,1);  break;                              //выводим четверг
    case 5: tft.drawCentreString("Friday",240,95,1);    break;                              //выводим пятница
    case 6: tft.drawCentreString("Saturday",240,95,1);  break;                              //выводим суббота
    case 7: tft.drawCentreString("Sunday",240,95,1);    break;}                             //выводим воскресенье
}}  SetStep=1; lock=0; flagtemp=false; preparing_the_screen();                              //выходим из программы часов и вызываем подпрограмму подготовки экрана
M2:if (setclock==1){                                                                        //если "setclock==1" входим в режим установки времени
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //затираем предыдущие надписи
    tft.setFreeFont(FSBI18);                                                                //выбираем шрифт
    tft.setTextColor(TFT_DARKGREY);                                                         //выбираем цвет текста
    tft.drawCentreString("Single click selection",240,205,1);                               //выводим надпись "Single click selection"
    tft.drawCentreString("Double click to return",240,240,1);                               //выводим надпись "Double click to return"
    tft.drawCentreString("Triple click switching reverse",240,275,1);                       //выводим надпись "Triple click switching reverse"
    alarmonoff=EEPROM.read(194);                                                            //читаем состояние будильника
    tft.setFreeFont(FSBI24); tft.setTextColor(TFT_RED);                                     //выбираем шрифт и цвет текста
  if (direction==0){tft.drawString("+",103,40,1);}                                          //если "direction==0" выводим +
  if (direction==1){tft.drawString("_",104,23,1);}                                          //если "direction==1" выводим -
    tmElements_t tm;                                                                        //вызов функции часов DS3231
    RTC.read(tm);                                                                           //переменная чтения DS3231
    int hh=tm.Hour;                                                                         //выводим часы
    int mm=tm.Minute;                                                                       //выводим минуты
    int ss=tm.Second;                                                                       //выводим секунды
    int dy=tm.Wday;                                                                         //выводим день недели
    int da=tm.Day;                                                                          //выводим число
    int mo=tm.Month;                                                                        //выводим месяц
    int ya=tm.Year;                                                                         //выводим год
    int xpos=137;                                                                           //начальная координата по х для вывода часов
    int ypos=35;                                                                            //начальная координата по y для вывода часов
    int xsecs=0;                                                                            //координата по x для вывода секунд
    int xpos1=100;                                                                          //начальная координата по х для вывода даты
    int ypos1=145;                                                                          //начальная координата по y для вывода даты
    int yYear=ypos1;                                                                        //координата по y для вывода года
    int xYear=0;                                                                            //координата по x для вывода года
  if (single==0){single++;                                                                  //включаем "single" счётчиком для однократного вывода часов
    tft.setTextColor(bordercolor,TFT_GREY40);                                               //выставляем выбранный цвет часов
    tft.setTextPadding(20);                                                                 //включаем обновление подложки шрифта
  if (hh<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания часов меньше 10 дорисовываем незначащий ноль
    xpos+=tft.drawNumber(hh,xpos,ypos,7);                                                   //выводим значение часов
    xpos+=tft.drawChar(':',xpos,ypos,7);                                                    //рисуем часовое и минутное двоеточие
  if (mm<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания минут меньше 10 дорисовываем незначащий ноль
    xpos+=tft.drawNumber(mm,xpos,ypos,7);                                                   //выводим значение минут
    xsecs=xpos;                                                                             //приравниваем координату x вывода секунд к начальной координате по x
    xpos+=tft.drawChar(':',xsecs,ypos,7);                                                   //рисуем секундное двоеточие
  if (ss<10)xpos+=tft.drawChar('0',xpos,ypos,7);                                            //если показания секунд меньше 10 дорисовываем незначащий ноль
    tft.drawNumber(ss,xpos,ypos,7);                                                         //выводим значение секунд
  if (da<10)xpos1+=tft.drawChar('0',xpos1,ypos1,7);                                         //если показания числа меньше 10 дорисовываем незначащий ноль
    xpos1+=tft.drawNumber(da,xpos1,ypos1,7);                                                //выводим значение числа
    xpos1+=tft.drawChar(' ',xpos1,ypos1,7);                                                 //формируем пробел между числом и месяцем
  if (mo<10)xpos1+=tft.drawChar('0',xpos1,ypos1,7);                                         //если показания месяца меньше 10 дорисовываем незначащий ноль
    xpos1+=tft.drawNumber(mo,xpos1,ypos1,7);                                                //выводим значение месяца
    xYear=xpos1;                                                                            //приравниваем координату x вывода года к координате вывода даты
    xpos1+=tft.drawChar(' ',xYear,yYear,7);                                                 //формируем пробел между месяцем и годом
    tft.drawNumber((int)ya+1970,xpos1,yYear,7);                                             //выводим значение года
    tft.setTextColor(bordercolor);                                                          //выбираем цвет вывода дня недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawCentreString("Monday",240,95,1);    break;                              //выводим понедельник
    case 2: tft.drawCentreString("Tuesday",240,95,1);   break;                              //выводим вторник
    case 3: tft.drawCentreString("Wednesday",240,95,1); break;                              //выводим среда
    case 4: tft.drawCentreString("Thursday",240,95,1);  break;                              //выводим четверг
    case 5: tft.drawCentreString("Friday",240,95,1);    break;                              //выводим пятница
    case 6: tft.drawCentreString("Saturday",240,95,1);  break;                              //выводим суббота
    case 7: tft.drawCentreString("Sunday",240,95,1);    break;}}                            //выводим воскресенье
while (place<8){                                                                            //находимся в цикле установки пока "place<8"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isSingle()){beep();                                                             //одним кликом
  if (direction==0){place++; if (place>7){place=1;}}                                        //если "direction==0" переключаем по одному параметру слева направо по кольцу
  if (direction==1){place--; if (place<1){place=7;}}}                                       //если "direction==1" переключаем по одному параметру справа налево по кольцу
  if (butt1.isDouble()){beep(); break;}                                                     //двойным кликом выходим из режима установки
  if (butt1.isTriple()){beep(); direction++; if(direction>1){direction=0;}                  //тройным кликом выбираем направление переключения пунктов
  if (direction==0){tft.drawString("+",103,40,1);}                                          //если "direction==0" выводим +
  if (direction==1){tft.fillRect(105,49,22,23,TFT_GREY40); tft.drawString("_",104,23,1);}}  //если "direction==1" затираем + и выводим -
  if (place==1){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения года
    tft.drawNumber((int)ya+1970,252,145,7);                                                 //восстанавливаем цвет значения года
  if (mm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mm,245,35,7);}                      //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mm,213,35,7);                                                         //выводим значение минут
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет часов
  if (hh<10){tft.drawChar('0',137,35,7); tft.drawNumber(hh,169,35,7);}                      //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hh,137,35,7);                                                         //выводим значение часов
  if (encoder.timeRight!=0){hh++; beep(); if (hh>23){hh=0;}                                 //выставляем новое значение часов на увеличение по кольцу
  if (hh<10){tft.drawChar('0',137,35,7); tft.drawNumber(hh,169,35,7);}                      //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hh,137,35,7); encoder.timeRight=0;}                                   //выводим значение часов
  if (encoder.timeLeft!=0){hh--; beep(); if (hh<0){hh=23;}                                  //выставляем новое значение часов на уменьшение по кольцу
  if (hh<10){tft.drawChar('0',137,35,7); tft.drawNumber(hh,169,35,7);}                      //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hh,137,35,7); encoder.timeLeft=0;}}                                   //выводим значения часов
  if (place==2){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения часов
  if (hh<10){tft.drawChar('0',137,35,7); tft.drawNumber(hh,169,35,7);}                      //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hh,137,35,7);                                                         //выводим значение часов
  if (ss<10){tft.drawChar('0',289,35,7); tft.drawNumber(ss,321,35,7);}                      //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ss,289,35,7);                                                         //выводим значение секунд
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет минут
  if (mm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mm,245,35,7);}                      //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mm,213,35,7);                                                         //выводим значение минут
  if (encoder.timeRight!=0){mm++; beep(); if (mm>59){mm=0;}                                 //выставляем новое значение минут на увеличение по кольцу
  if (mm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mm,245,35,7);}                      //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mm,213,35,7); encoder.timeRight=0;}                                   //выводим значение минут
  if (encoder.timeLeft!=0){mm--; beep(); if (mm<0){mm=59;}                                  //выставляем новое значение минут на уменьшение по кольцу
  if (mm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mm,245,35,7);}                      //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mm,213,35,7); encoder.timeLeft=0;}}                                   //выводим значение минут
  if (place==3){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения минут
  if (mm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mm,245,35,7);}                      //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mm,213,35,7);                                                         //выводим значение минут
    tft.setTextColor(bordercolor);                                                          //выбираем цвет текста для восстановления значения дней недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawCentreString("Monday",240,95,1);    break;                              //выводим понедельник
    case 2: tft.drawCentreString("Tuesday",240,95,1);   break;                              //выводим вторник
    case 3: tft.drawCentreString("Wednesday",240,95,1); break;                              //выводим среда
    case 4: tft.drawCentreString("Thursday",240,95,1);  break;                              //выводим четверг
    case 5: tft.drawCentreString("Friday",240,95,1);    break;                              //выводим пятница
    case 6: tft.drawCentreString("Saturday",240,95,1);  break;                              //выводим суббота
    case 7: tft.drawCentreString("Sunday",240,95,1);    break;}                             //выводим воскресенье
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет секунд
  if (ss<10){tft.drawChar('0',289,35,7); tft.drawNumber(ss,321,35,7);}                      //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ss,289,35,7);                                                         //выводим значение секунд
  if (encoder.timeRight!=0){ss++; beep(); if (ss>59){ss=0;}                                 //выставляем новое значение секунд на увеличение по кольцу
  if (ss<10){tft.drawChar('0',289,35,7); tft.drawNumber(ss,321,35,7);}                      //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ss,289,35,7); encoder.timeRight=0;}                                   //выводим значение секунд
  if (encoder.timeLeft!=0){ss--; beep(); if (ss<0){ss=59;}                                  //выставляем новое значение секунд на уменьшение по кольцу
  if (ss<10){tft.drawChar('0',289,35,7); tft.drawNumber(ss,321,35,7);}                      //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ss,289,35,7); encoder.timeLeft=0;}}                                   //выводим значение секунд
  if (place==4){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения секунд
  if (ss<10){tft.drawChar('0',289,35,7); tft.drawNumber(ss,321,35,7);}                      //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ss,289,35,7);                                                         //выводим значение секунд
  if (da<10){tft.drawChar('0',100,145,7); tft.drawNumber(da,132,145,7);}                    //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,100,145,7);                                                        //выводим значение даты
    tft.setTextColor(TFT_RED);                                                              //выбираем цвет дня недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawCentreString("Monday",240,95,1);    break;                              //выводим понедельник
    case 2: tft.drawCentreString("Tuesday",240,95,1);   break;                              //выводим вторник
    case 3: tft.drawCentreString("Wednesday",240,95,1); break;                              //выводим среда
    case 4: tft.drawCentreString("Thursday",240,95,1);  break;                              //выводим четверг
    case 5: tft.drawCentreString("Friday",240,95,1);    break;                              //выводим пятница
    case 6: tft.drawCentreString("Saturday",240,95,1);  break;                              //выводим суббота
    case 7: tft.drawCentreString("Sunday",240,95,1);    break;}                             //выводим воскресенье
  if (encoder.timeRight!=0){dy++; beep(); if (dy>7){dy=1;}                                  //выбираем день недели на увеличение по кольцу
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Monday",240,95,1);    break;                                      //выводим понедельник
    case 2: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Tuesday",240,95,1);   break;                                      //выводим вторник
    case 3: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Wednesday",240,95,1); break;                                      //выводим среда
    case 4: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Thursday",240,95,1);  break;                                      //выводим четверг
    case 5: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Friday",240,95,1);    break;                                      //выводим пятница
    case 6: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Saturday",240,95,1);  break;                                      //выводим суббота
    case 7: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Sunday",240,95,1);    break;}                                     //выводим воскресенье
    encoder.timeRight=0;}                                                                   //обнуляем время/признак вращения вправо
  if (encoder.timeLeft!=0){dy--; beep(); if (dy<1){dy=7;}                                   //выбираем день недели на уменьшение по кольцу
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Monday",240,95,1);    break;                                      //выводим понедельник
    case 2: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Tuesday",240,95,1);   break;                                      //выводим вторник
    case 3: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Wednesday",240,95,1); break;                                      //выводим среда
    case 4: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Thursday",240,95,1);  break;                                      //выводим четверг
    case 5: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Friday",240,95,1);    break;                                      //выводим пятница
    case 6: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Saturday",240,95,1);  break;                                      //выводим суббота
    case 7: tft.fillRect(135,94,215,42,TFT_GREY40);                                         //затираем предыдущую надпись
    tft.drawCentreString("Sunday",240,95,1);    break;}                                     //выводим воскресенье
    encoder.timeLeft=0;}}                                                                   //обнуляем время/признак вращения влево
  if (place==5){tft.setTextColor(bordercolor);                                              //выбираем цвет текста для восстановления значения дней недели
  switch (dy){                                                                              //--- дни недели ---
    case 1: tft.drawCentreString("Monday",240,95,1);    break;                              //выводим понедельник
    case 2: tft.drawCentreString("Tuesday",240,95,1);   break;                              //выводим вторник
    case 3: tft.drawCentreString("Wednesday",240,95,1); break;                              //выводим среда
    case 4: tft.drawCentreString("Thursday",240,95,1);  break;                              //выводим четверг
    case 5: tft.drawCentreString("Friday",240,95,1);    break;                              //выводим пятница
    case 6: tft.drawCentreString("Saturday",240,95,1);  break;                              //выводим суббота
    case 7: tft.drawCentreString("Sunday",240,95,1);    break;}                             //выводим воскресенье
  if (mo<10){tft.drawChar('0',176,145,7); tft.drawNumber(mo,208,145,7);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,176,145,7);                                                        //выводим значение месяца  
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет даты
  if (da<10){tft.drawChar('0',100,145,7); tft.drawNumber(da,132,145,7);}                    //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,100,145,7);                                                        //выводим значение даты
  if (encoder.timeRight!=0){da++; beep();                                                   //выставляем новое значение даты на увеличение по кольцу
  switch (mo){                                                                              //функция выбора месяца в +
    case 1: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 1
    case 2: if (da>29){da=1;} break;                                                        //ограничиваем количество дней 29 для месяца 2
    case 3: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 3
    case 4: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 4
    case 5: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 5
    case 6: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 6
    case 7: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 7
    case 8: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 8
    case 9: if (da>31){da=1;} break;                                                        //ограничиваем количество дней 31 для месяца 9
    case 10: if (da>31){da=1;} break;                                                       //ограничиваем количество дней 31 для месяца 10
    case 11: if (da>31){da=1;} break;                                                       //ограничиваем количество дней 31 для месяца 11
    case 12: if (da>31){da=1;} break;}                                                      //ограничиваем количество дней 31 для месяца 12
  if (da<10){tft.drawChar('0',100,145,7); tft.drawNumber(da,132,145,7);}                    //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,100,145,7); encoder.timeRight=0;}                                  //выводим значение даты
  if (encoder.timeLeft!=0){da--; beep();                                                    //выставляем новое значение даты на уменьшение по кольцу
  switch (mo){                                                                              //функция выбора месяца в -
    case 1: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 1
    case 2: if (da<1){da=29;} break;                                                        //ограничиваем количество дней 29 для месяца 2
    case 3: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 3
    case 4: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 4
    case 5: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 5
    case 6: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 6
    case 7: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 7
    case 8: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 8
    case 9: if (da<1){da=31;} break;                                                        //ограничиваем количество дней 31 для месяца 9
    case 10: if (da<1){da=31;} break;                                                       //ограничиваем количество дней 31 для месяца 10
    case 11: if (da<1){da=31;} break;                                                       //ограничиваем количество дней 31 для месяца 11
    case 12: if (da<1){da=31;} break;}                                                      //ограничиваем количество дней 31 для месяца 12
  if (da<10){tft.drawChar('0',100,145,7); tft.drawNumber(da,132,145,7);}                    //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,100,145,7); encoder.timeLeft=0;}}                                  //выводим значение даты
  if (place==6){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения даты
  if (da<10){tft.drawChar('0',100,145,7); tft.drawNumber(da,132,145,7);}                    //если показания даты меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(da,100,145,7);                                                        //выводим значение даты
    tft.drawNumber((int)ya+1970,252,145,7);                                                 //восстанавливаем цвет значения года
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет месяца
  if (mo<10){tft.drawChar('0',176,145,7); tft.drawNumber(mo,208,145,7);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,176,145,7);                                                        //выводим значение месяца
  if (encoder.timeRight!=0){mo++; beep(); if (mo>12){mo=1;}                                 //выставляем новое значение года на увеличение по кольцу
  if (mo<10){tft.drawChar('0',176,145,7); tft.drawNumber(mo,208,145,7);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,176,145,7); encoder.timeRight=0;}                                  //выводим значение месяца
  if (encoder.timeLeft!=0){mo--; beep(); if (mo<1){mo=12;}                                  //выставляем новое значение года на уменьшение по кольцу
  if (mo<10){tft.drawChar('0',176,145,7); tft.drawNumber(mo,208,145,7);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,176,145,7); encoder.timeLeft=0;}}                                  //выводим значение месяца
  if (place==7){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения месяца
  if (mo<10){tft.drawChar('0',176,145,7); tft.drawNumber(mo,208,145,7);}                    //если показания месяца меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mo,176,145,7);                                                        //выводим значение месяца
  if (hh<10){tft.drawChar('0',137,35,7); tft.drawNumber(hh,169,35,7);}                      //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hh,137,35,7);                                                         //выводим значение часов
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет года
    tft.drawNumber((int)ya+1970,252,145,7);                                                 //выводим значение года
  if (encoder.timeRight!=0){ya++; beep(); if (ya>59){ya=49;}                                //выставляем новое значение года на увеличение по кольцу
    tft.drawNumber((int)ya+1970,252,145,7); encoder.timeRight=0;}                           //выводим значение года
  if (encoder.timeLeft!=0){ya--; beep(); if (ya<49){ya=59;}                                 //выставляем новое значение года на уменьшение по кольцу
    tft.drawNumber((int)ya+1970,252,145,7); encoder.timeLeft=0;}}                           //выводим значение года
}   Wire.beginTransmission(104);                                                            //при выходе из цикла установки опрашиваем адрес I2C
    Wire.write(0);                                                                          //начинаем передачу данных
    Wire.write(decToBcd(ss));                                                               //задаем секунды
    Wire.write(decToBcd(mm));                                                               //задаем минуты
    Wire.write(decToBcd(hh));                                                               //задаем часы
    Wire.write(decToBcd(dy));                                                               //задаем день недели
    Wire.write(decToBcd(da));                                                               //задаем число
    Wire.write(decToBcd(mo));                                                               //задаем месяц
    Wire.write(decToBcd(tmYearToY2k(ya)));                                                  //задаем год
    Wire.endTransmission();                                                                 //завершаем передачу данных
    tft.fillRect(30,24,420,33,TFT_GREY40); tft.fillRect(30,274,420,33,TFT_GREY40);          //затираем предыдущие надписи
    setclock=0; single=0; flagtemp=false; goto M1;}                                         //выходим из режима коррекции часов
M3:if (setalarm==1){                                                                        //если "setalarm==1" входим в режим установки будильника
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //затираем предыдущие надписи
    tft.setFreeFont(FSBI24); tft.setTextColor(TFT_RED);                                     //выбираем шрифт и цвет текста
  if (directionAlarm==0){tft.drawString("+",103,40,1);}                                     //если "directionAlarm==0" выводим +
  if (directionAlarm==1){tft.drawString("_",104,23,1);}                                     //если "directionAlarm==1" выводим -
    tft.setFreeFont(FSBI12); tft.setTextColor(TFT_DARKGREY);                                //выбираем шрифт и цвет текста
    tft.drawString("AUTOMATIC EXIT AFTER",70,275,1);                                        //выводим надпись "AUTOMATIC EXIT AFTER"
    tft.drawString("sec",380,275,1);                                                        //выводим надпись "sec"
    tft.setFreeFont(FSBI18);                                                                //выбираем шрифт
    tft.drawCentreString("Single click to set the alarm",240,170,1);                        //выводим надпись "Single click to set the alarm"
    tft.drawCentreString("Double click ON/OFF alarm",240,205,1);                            //выводим надпись "Double click ON/OFF alarm"
    tft.drawCentreString("Triple click switching reverse",240,240,1);                       //выводим надпись "Triple click switching reverse"
    hhalarm=EEPROM.read(191);                                                               //читаем значение часов будильника
    mmalarm=EEPROM.read(192);                                                               //читаем значение минут будильника
    ssalarm=EEPROM.read(193);                                                               //читаем значение секунд будильника
    alarmonoff=EEPROM.read(194);                                                            //читаем состояние будильника
    tft.setTextColor(bordercolor);                                                          //выбираем цвет текста
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7);                                                    //выводим значение часов
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7);                                                    //выводим значение минут
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7);                                                    //выводим значение секунд
    tft.drawChar(':',201,35,7); tft.drawChar(':',277,35,7);                                 //рисуем двоеточие
    tft.setFreeFont(FSSB24);                                                                //выбираем шрифт
  if (alarmonoff==0){tft.setTextColor(TFT_DARKGREY);                                        //если будильник выключен
    tft.drawCentreString("Alarm OFF",240,105,1);}                                           //выводим надпись "Alarm OFF"
  if (alarmonoff==1){tft.setTextColor(TFT_RED); tft.drawCentreString("Alarm ON",240,105,1);}//если будильник включен выводим надпись "Alarm"
while (place<8){                                                                            //находимся в цикле установки пока "place<4"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isSingle()){beep(); valAlarm=0;                                                 //одним кликом
  if (directionAlarm==0){place++; if (place>3){place=1;}}                                   //если "directionAlarm==0" переключаем по одному параметру слева направо по кольцу
  if (directionAlarm==1){place--; if (place<1){place=3;}}}                                  //если "directionAlarm==1" переключаем по одному параметру справа налево по кольцу
  if (butt1.isDouble()){beep(); alarmonoff++; if (alarmonoff>1){alarmonoff=0;}              //двойным кликом включаем/выключаем будильник
  if (alarmonoff==0){tft.fillRect(120,102,243,38,TFT_GREY40);                               //если будильник выключен затираем предыдущую надпись
    tft.setTextColor(TFT_DARKGREY); tft.drawCentreString("Alarm OFF",240,105,1);}           //выводим надпись "Alarm OFF"
  if (alarmonoff==1){tft.fillRect(120,102,243,38,TFT_GREY40);                               //если будильник включен затираем предыдущую надпись
    tft.setTextColor(TFT_RED); tft.drawCentreString("Alarm ON",240,105,1);} valAlarm=0;}    //выводим надпись "Alarm ON"
  if (butt1.isTriple()){beep(); directionAlarm++; if(directionAlarm>1){directionAlarm=0;}   //тройным кликом выбираем направление переключения пунктов
    tft.setFreeFont(FSBI24); tft.setTextColor(TFT_RED);                                     //выбираем шрифт и цвет текста
  if (directionAlarm==0){tft.drawString("+",103,40,1);}                                     //если "direction==0" выводим +
  if (directionAlarm==1){tft.fillRect(105,49,22,23,TFT_GREY40);                             //если "direction==1" затираем +
    tft.drawString("_",104,23,1);} valAlarm=0;}                                             //и выводим -
  if (millis()-AlarmMillis>=1){AlarmMillis=millis(); valAlarm++; int delAlarm;              //формируем задержку выхода из установки будильника
  switch(valAlarm){                                                                         //функция перевода значений счётчика в секунды с обратным отсчётом
    case   1: delAlarm=5; break;                                                            //если значение счётчика равно 1 то отображается 5сек
    case 140: delAlarm=4; break;                                                            //---------------------------- 70 -------------- 4сек
    case 280: delAlarm=3; break;                                                            //---------------------------- 140 ------------- 3сек
    case 420: delAlarm=2; break;                                                            //---------------------------- 210 ------------- 2сек
    case 560: delAlarm=1; break;                                                            //---------------------------- 280 ------------- 1сек
    case 700: delAlarm=0; break;}                                                           //---------------------------- 350 ------------- 0сек
    tft.setTextColor(TFT_RED,TFT_GREY40); tft.drawNumber(delAlarm,360,273,4);}              //выводим обратное значение в секундах
  if (valAlarm>=AlarmTime){valAlarm=0; beep(); break;}                                      //по истечении времени если будильник установлен выходим из режима установки будильника
  if (place==1){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения секунд
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7);                                                    //выводим значение секунд
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7);                                                    //выводим значение минут
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет часов
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7);                                                    //выводим значение часов
  if (encoder.timeRight!=0){hhalarm++; beep(); if (hhalarm>23){hhalarm=0;}                  //выставляем новое значение часов на увеличение по кольцу
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7); valAlarm=0; encoder.timeRight=0;}                  //выводим значение часов
  if (encoder.timeLeft!=0){hhalarm--; beep(); if (hhalarm<0){hhalarm=23;}                   //выставляем новое значение часов на уменьшение по кольцу
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7); valAlarm=0; encoder.timeLeft=0;}}                  //выводим значения часов
  if (place==2){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения часов
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7);                                                    //выводим значение часов
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7);                                                    //выводим значение секунд
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет минут
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7);                                                    //выводим значение минут
  if (encoder.timeRight!=0){mmalarm++; beep(); if (mmalarm>59){mmalarm=0;}                  //выставляем новое значение минут на увеличение по кольцу
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7); valAlarm=0; encoder.timeRight=0;}                  //выводим значение минут
  if (encoder.timeLeft!=0){mmalarm--; beep(); if (mmalarm<0){mmalarm=59;}                   //выставляем новое значение минут на уменьшение по кольцу
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7); valAlarm=0; encoder.timeLeft=0;}}                  //выводим значение минут
  if (place==3){tft.setTextColor(bordercolor,TFT_GREY40);                                   //выбираем цвет текста для восстановления значения минут
  if (mmalarm<10){tft.drawChar('0',213,35,7); tft.drawNumber(mmalarm,245,35,7);}            //если показания минут меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(mmalarm,213,35,7); encoder.timeRight=0;                               //выводим значение минут
  if (hhalarm<10){tft.drawChar('0',137,35,7); tft.drawNumber(hhalarm,169,35,7);}            //если показания часов меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(hhalarm,137,35,7);                                                    //выводим значение часов
    tft.setTextColor(TFT_RED,TFT_GREY40);                                                   //выбираем цвет секунд
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7);                                                    //выводим значение секунд
  if (encoder.timeRight!=0){ssalarm++; beep(); if (ssalarm>59){ssalarm=0;}                  //выставляем новое значение секунд на увеличение по кольцу
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7); valAlarm=0; encoder.timeRight=0;}                  //выводим значение секунд
  if (encoder.timeLeft!=0){ssalarm--; beep(); if (ssalarm<0){ssalarm=59;}                   //выставляем новое значение секунд на уменьшение по кольцу
  if (ssalarm<10){tft.drawChar('0',289,35,7); tft.drawNumber(ssalarm,321,35,7);}            //если показания секунд меньше 10 дорисовываем незначащий ноль
  else tft.drawNumber(ssalarm,289,35,7); valAlarm=0; encoder.timeLeft=0;}}                  //выводим значение секунд
}   EEPROM.update(191,hhalarm); EEPROM.update(192,mmalarm); EEPROM.update(193,ssalarm);     //сохраняем установленные значения часов, минут и секунд будильника
    EEPROM.update(194,alarmonoff);                                                          //сохраняем состояние on/off будильника
    setalarm=0; flagtemp=false; goto M1;}}                                                  //выходим из режима установки будильника
void memory_reading(){//**************************************** Чтение из памяти *******************************************************************
  for(int i=0; i<2; i++){                                                                   //включаем цикл
    tft.drawRect(i,i,480-i*2,320-i*2,bordercolor);                                          //рисуем наружную окантовку экрана
    tft.drawRoundRect(6+i,6+i,468-i*2,308-i*2,8-i,bordercolor);}                            //рисуем внутреннюю окантовку экрана с закруглёнными углами
M1: tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //рисуем тёмно серый прямоугольник фона
    tft.setFreeFont(FSBI12); tft.setTextColor(bordercolor);                                 //подключаем внешний шрифт FSBI12
    tft.drawCentreString("-- MEMORY READING --",240,17,1);                                  //выводим надпись "-- MEMORY READING --"
    tft.drawCentreString("Azimuthal rotary device v",220,45,1);                             //выводим подложку надписи "Azimuthal rotary device v"
    tft.drawFloat(version,1,355,45,1);                                                      //выводим номер версии
    tft.drawCentreString(s,240,75,1);                                                       //выводим число, месяц и год создания программы
    tft.setFreeFont(FSBI18); tft.setTextColor(TFT_DARKGREY);                                //подключаем внешний шрифт FSBI18, выбираем цвет текста
    tft.drawCentreString("Single click to exit",240,205,1);                                 //выводим надпись "Single click to exit"
    tft.drawCentreString("Double click the select ringtone",240,240,1);                     //выводим надпись "Double click the select ringtone"
    tft.drawCentreString("Triple click to display the clock",240,275,1);                    //выводим надпись "Triple click to display the clock"
    tft.setTextColor(TFT_SILVER); tft.drawCentreString("Position N:",220,120,1);            //выводим надпись "Position N:"
  if ((Clock==1)&&(nomodule==0)){symbol_clock();}                                           //если вывод часов разрешен и модуль подключен вызываем символ часов
while (MReadPos<116){                                                                       //находимся в цикле пока "MReadPos<116"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isSingle()){beep(); MReadPos=116;}                                              //однократным кликом выходим из цикла
  if (butt1.isDouble()){beep(); selringtone=1; single=0; goto M2;}                          //двойным кликом входим в выбор мелодии при загрузке программы
  if (butt1.isTriple()){Clock++; beep(); if (Clock>1){Clock=0;}                             //тройным кликом разрешаем или запрещаем вывод часов в основной программе
    EEPROM.update(195,Clock);                                                               //запоминаем состояние "Clock"
  if (Clock==0){tft.fillCircle(75,135,31,TFT_GREY40);}                                      //если вывод часов запрещён затираем символ
  if ((Clock==1)&&(nomodule==0)){symbol_clock();}}                                          //если часы разрешены выводим символ часов
  if (encoder.timeRight!=0){MReadPos++; beep(); single=0; MRPos=0;                          //включаем счётчик вращения энкодера вправо
  if (MReadPos>115){MReadPos=0;} encoder.timeRight=0;}                                      //ограничиваем значение энкодера 115 импульсов, работает по кольцу
  if (encoder.timeLeft!=0){MReadPos--; beep(); single=0; MRPos=0;                           //включаем счётчик вращения энкодера влево
  if (MReadPos<0){MReadPos=115;} encoder.timeLeft=0;}                                       //ограничиваем значение энкодера 0 импульсов, работает по кольцу
    tft.setTextColor(TFT_SILVER,TFT_GREY40); tft.setTextPadding(80);                        //выбираем цвет и включаем обновление подложки
  if (MRPos==0){MRPos++; tft.drawNumber(MReadPos,310,120,1);}                               //выводим номера позиций
    tft.setTextColor(bordercolor,TFT_GREY40); tft.setTextPadding(175);                      //выбираем цвет и включаем обновление подложки
  switch(MReadPos){                                                                         //функция перебора ячеек памяти
    case 0: if (single==0){single++; Sensor=word(EEPROM.read(0),EEPROM.read(1));            //считываем текущее состояние режима
    tft.drawNumber(Sensor,295,170,1); tft.drawCentreString("Sensor",195,170,1);} break;     //выводим полученное значение "Sensor"
    case 1: if (single==0){single++; border=EEPROM.read(4);                                 //считываем текущее состояние режима
    tft.drawNumber(border,295,170,1); tft.drawCentreString("border",195,170,1);} break;     //выводим полученное значение "border"
    case 2: if (single==0){single++; Pencoder=word(EEPROM.read(5),EEPROM.read(6));          //считываем текущее состояние режима
    tft.drawNumber(Pencoder,295,170,1); tft.drawCentreString("Pencoder",195,170,1);} break; //выводим полученное значение "Sensor"
    case 3: if (single==0){single++; InvDisp=EEPROM.read(13);                               //считываем текущее состояние режима
    tft.drawNumber(InvDisp,295,170,1); tft.drawCentreString("InvDisp",195,170,1);} break;   //выводим полученное значение "InvDisp"
    case 4: if (single==0){single++; RotDisp=EEPROM.read(14);                               //считываем текущее состояние режима
    tft.drawNumber(RotDisp,295,170,1); tft.drawCentreString("RotDisp",195,170,1);} break;   //выводим полученное значение "RotDisp"
    case 5: if (single==0){single++; stp=EEPROM.read(15);                                   //считываем текущее состояние режима
    tft.drawNumber(stp,295,170,1); tft.drawCentreString("stp",195,170,1);} break;           //выводим полученное значение "stp"
    case 6: if (single==0){single++; ClockTime=EEPROM.read(16);                             //считываем текущее состояние режима
    tft.drawNumber(ClockTime*100,295,170,1);tft.drawCentreString("ClockTime",195,170,1);}   //выводим полученное значение "ClockTime"
    break;
    case 7: if (single==0){single++; TONE=EEPROM.read(17);                                  //считываем текущее состояние режима
    tft.drawNumber(TONE,295,170,1); tft.drawCentreString("TONE",195,170,1);} break;         //выводим полученное значение "TONE"
    case 8: if (single==0){single++; can36=EEPROM.read(18);                                 //считываем текущее состояние режима
    tft.drawNumber(can36,295,170,1); tft.drawCentreString("can36",195,170,1);} break;       //выводим полученное значение "can36"
    case 9: if (single==0){single++; nam36=EEPROM.read(19);                                 //считываем текущее состояние режима
    tft.drawNumber(nam36,295,170,1); tft.drawCentreString("nam36",195,170,1);} break;       //выводим полученное значение "nam36"
    case 10: if (single==0){single++; lam36=EEPROM.read(20);                                //считываем текущее состояние режима
    tft.drawNumber(lam36,295,170,1); tft.drawCentreString("lam36",195,170,1);} break;       //выводим полученное значение "lam36"
    case 11: if (single==0){single++; eur36=EEPROM.read(21);                                //считываем текущее состояние режима
    tft.drawNumber(eur36,295,170,1); tft.drawCentreString("eur36",195,170,1);} break;       //выводим полученное значение "eur36"
    case 12: if (single==0){single++; jap36=EEPROM.read(22);                                //считываем текущее состояние режима
    tft.drawNumber(jap36,295,170,1); tft.drawCentreString("jap36",195,170,1);} break;       //выводим полученное значение "jap36"
    case 13: if (single==0){single++; ind36=EEPROM.read(23);                                //считываем текущее состояние режима
    tft.drawNumber(ind36,295,170,1); tft.drawCentreString("ind36",195,170,1);} break;       //выводим полученное значение "ind36"
    case 14: if (single==0){single++; aus36=EEPROM.read(24);                                //считываем текущее состояние режима
    tft.drawNumber(aus36,295,170,1); tft.drawCentreString("aus36",195,170,1);} break;       //выводим полученное значение "aus36"
    case 15: if (single==0){single++; afr36=EEPROM.read(25);                                //считываем текущее состояние режима
    tft.drawNumber(afr36,295,170,1); tft.drawCentreString("afr36",195,170,1);} break;       //выводим полученное значение "afr36"
    case 16: if (single==0){single++; can24=EEPROM.read(26);                                //считываем текущее состояние режима
    tft.drawNumber(can24,295,170,1); tft.drawCentreString("can24",195,170,1);} break;       //выводим полученное значение "can24"
    case 17: if (single==0){single++; nam24=EEPROM.read(27);                                //считываем текущее состояние режима
    tft.drawNumber(nam24,295,170,1); tft.drawCentreString("nam24",195,170,1);} break;       //выводим полученное значение "nam24"
    case 18: if (single==0){single++; lam24=EEPROM.read(28);                                //считываем текущее состояние режима
    tft.drawNumber(lam24,295,170,1); tft.drawCentreString("lam24",195,170,1);} break;       //выводим полученное значение "lam24"
    case 19: if (single==0){single++; eur24=EEPROM.read(29);                                //считываем текущее состояние режима
    tft.drawNumber(eur24,295,170,1); tft.drawCentreString("eur24",195,170,1);} break;       //выводим полученное значение "eur24"
    case 20: if (single==0){single++; jap24=EEPROM.read(30);                                //считываем текущее состояние режима
    tft.drawNumber(jap24,295,170,1); tft.drawCentreString("jap24",195,170,1);} break;       //выводим полученное значение "jap24"
    case 21: if (single==0){single++; ind24=EEPROM.read(31);                                //считываем текущее состояние режима
    tft.drawNumber(ind24,295,170,1); tft.drawCentreString("ind24",195,170,1);} break;       //выводим полученное значение "ind24"
    case 22: if (single==0){single++; aus24=EEPROM.read(32);                                //считываем текущее состояние режима
    tft.drawNumber(aus24,295,170,1); tft.drawCentreString("aus24",195,170,1);} break;       //выводим полученное значение "aus24"
    case 23: if (single==0){single++; afr24=EEPROM.read(33);                                //считываем текущее состояние режима
    tft.drawNumber(afr24,295,170,1); tft.drawCentreString("afr24",195,170,1);} break;       //выводим полученное значение "afr24"
    case 24: if (single==0){single++; can16=EEPROM.read(34);                                //считываем текущее состояние режима
    tft.drawNumber(can16,295,170,1); tft.drawCentreString("can16",195,170,1);} break;       //выводим полученное значение "can16"
    case 25: if (single==0){single++; nam16=EEPROM.read(35);                                //считываем текущее состояние режима
    tft.drawNumber(nam16,295,170,1); tft.drawCentreString("nam16",195,170,1);} break;       //выводим полученное значение "nam16"
    case 26: if (single==0){single++; lam16=EEPROM.read(36);                                //считываем текущее состояние режима
    tft.drawNumber(lam16,295,170,1); tft.drawCentreString("lam16",195,170,1);} break;       //выводим полученное значение "lam16"
    case 27: if (single==0){single++; eur16=EEPROM.read(37);                                //считываем текущее состояние режима
    tft.drawNumber(eur16,295,170,1); tft.drawCentreString("eur16",195,170,1);} break;       //выводим полученное значение "eur16"
    case 28: if (single==0){single++; jap16=EEPROM.read(38);                                //считываем текущее состояние режима
    tft.drawNumber(jap16,295,170,1); tft.drawCentreString("jap16",195,170,1);} break;       //выводим полученное значение "jap16"
    case 29: if (single==0){single++; ind16=EEPROM.read(39);                                //считываем текущее состояние режима
    tft.drawNumber(ind16,295,170,1); tft.drawCentreString("ind16",195,170,1);} break;       //выводим полученное значение "ind16"
    case 30: if (single==0){single++; aus16=EEPROM.read(40);                                //считываем текущее состояние режима
    tft.drawNumber(aus16,295,170,1); tft.drawCentreString("aus16",195,170,1);} break;       //выводим полученное значение "aus16"
    case 31: if (single==0){single++; afr16=EEPROM.read(41);                                //считываем текущее состояние режима
    tft.drawNumber(afr16,295,170,1); tft.drawCentreString("afr16",195,170,1);} break;       //выводим полученное значение "afr16"
    case 32: if (single==0){single++; can=word(EEPROM.read(42),EEPROM.read(43));            //считываем текущее состояние режима
    tft.drawNumber(can,295,170,1); tft.drawCentreString("can",195,170,1);} break;           //выводим полученное значение "can"
    case 33: if (single==0){single++; nam=word(EEPROM.read(44),EEPROM.read(45));            //считываем текущее состояние режима
    tft.drawNumber(nam,295,170,1); tft.drawCentreString("nam",195,170,1);} break;           //выводим полученное значение "nam"
    case 34: if (single==0){single++; lam=word(EEPROM.read(46),EEPROM.read(47));            //считываем текущее состояние режима
    tft.drawNumber(lam,295,170,1); tft.drawCentreString("lam",195,170,1);} break;           //выводим полученное значение "lam"
    case 35: if (single==0){single++; eur=word(EEPROM.read(48),EEPROM.read(49));            //считываем текущее состояние режима
    tft.drawNumber(eur,295,170,1); tft.drawCentreString("eur",195,170,1);} break;           //выводим полученное значение "eur"
    case 36: if (single==0){single++; jap=word(EEPROM.read(50),EEPROM.read(51));            //считываем текущее состояние режима
    tft.drawNumber(jap,295,170,1); tft.drawCentreString("jap",195,170,1);} break;           //выводим полученное значение "jap"
    case 37: if (single==0){single++; ind=word(EEPROM.read(52),EEPROM.read(53));            //считываем текущее состояние режима
    tft.drawNumber(ind,295,170,1); tft.drawCentreString("ind",195,170,1);} break;           //выводим полученное значение "ind"
    case 38: if (single==0){single++; aus=word(EEPROM.read(54),EEPROM.read(55));            //считываем текущее состояние режима
    tft.drawNumber(aus,295,170,1); tft.drawCentreString("aus",195,170,1);} break;           //выводим полученное значение "aus"
    case 39: if (single==0){single++; afr=word(EEPROM.read(56),EEPROM.read(57));            //считываем текущее состояние режима
    tft.drawNumber(afr,295,170,1); tft.drawCentreString("afr",195,170,1);} break;           //выводим полученное значение "afr"
    case 40: if (single==0){single++; can72=EEPROM.read(58);                                //считываем текущее состояние режима
    tft.drawNumber(can72,295,170,1); tft.drawCentreString("can72",195,170,1);} break;       //выводим полученное значение "can72"
    case 41: if (single==0){single++; nam72=EEPROM.read(59);                                //считываем текущее состояние режима
    tft.drawNumber(nam72,295,170,1); tft.drawCentreString("nam72",195,170,1);} break;       //выводим полученное значение "nam72"
    case 42: if (single==0){single++; lam72=EEPROM.read(60);                                //считываем текущее состояние режима
    tft.drawNumber(lam72,295,170,1); tft.drawCentreString("lam72",195,170,1);} break;       //выводим полученное значение "lam72"
    case 43: if (single==0){single++; eur72=EEPROM.read(61);                                //считываем текущее состояние режима
    tft.drawNumber(eur72,295,170,1); tft.drawCentreString("eur72",195,170,1);} break;       //выводим полученное значение "eur72"
    case 44: if (single==0){single++; jap72=EEPROM.read(62);                                //считываем текущее состояние режима
    tft.drawNumber(jap72,295,170,1); tft.drawCentreString("jap72",195,170,1);} break;       //выводим полученное значение "jap72"
    case 45: if (single==0){single++; ind72=EEPROM.read(63);                                //считываем текущее состояние режима
    tft.drawNumber(ind72,295,170,1); tft.drawCentreString("ind72",195,170,1);} break;       //выводим полученное значение "ind72"
    case 46: if (single==0){single++; aus72=EEPROM.read(64);                                //считываем текущее состояние режима
    tft.drawNumber(aus72,295,170,1); tft.drawCentreString("aus72",195,170,1);} break;       //выводим полученное значение "aus72"
    case 47: if (single==0){single++; afr72=EEPROM.read(65);                                //считываем текущее состояние режима
    tft.drawNumber(afr72,295,170,1); tft.drawCentreString("afr72",195,170,1);} break;       //выводим полученное значение "afr72"
    case 48: if (single==0){single++; music1=word(EEPROM.read(66),EEPROM.read(67));         //считываем текущее состояние режима
    tft.drawNumber(music1,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music1"
    case 49: if (single==0){single++; music2=word(EEPROM.read(68),EEPROM.read(69));         //считываем текущее состояние режима
    tft.drawNumber(music2,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music2"
    case 50: if (single==0){single++; music3=word(EEPROM.read(70),EEPROM.read(71));         //считываем текущее состояние режима
    tft.drawNumber(music3,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music3"
    case 51: if (single==0){single++; music4=word(EEPROM.read(72),EEPROM.read(73));         //считываем текущее состояние режима
    tft.drawNumber(music4,295,170,1); tft.drawCentreString("D#",195,170,1);} break;         //выводим полученное значение "music4"
    case 52: if (single==0){single++; music5=word(EEPROM.read(74),EEPROM.read(75));         //считываем текущее состояние режима
    tft.drawNumber(music5,295,170,1); tft.drawCentreString("D#",195,170,1);} break;         //выводим полученное значение "music5"
    case 53: if (single==0){single++; music6=word(EEPROM.read(76),EEPROM.read(77));         //считываем текущее состояние режима
    tft.drawNumber(music6,295,170,1); tft.drawCentreString("D#",195,170,1);} break;         //выводим полученное значение "music6"
    case 54: if (single==0){single++; music7=word(EEPROM.read(78),EEPROM.read(79));         //считываем текущее состояние режима
    tft.drawNumber(music7,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music7"
    case 55: if (single==0){single++; music8=word(EEPROM.read(80),EEPROM.read(81));         //считываем текущее состояние режима
    tft.drawNumber(music8,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music8"
    case 56: if (single==0){single++; music9=word(EEPROM.read(82),EEPROM.read(83));         //считываем текущее состояние режима
    tft.drawNumber(music9,295,170,1); tft.drawCentreString("E",195,170,1);} break;          //выводим полученное значение "music9"
    case 57: if (single==0){single++; music10=word(EEPROM.read(84),EEPROM.read(85));        //считываем текущее состояние режима
    tft.drawNumber(music10,295,170,1); tft.drawCentreString("D#",195,170,1);} break;        //выводим полученное значение "music10"
    case 58: if (single==0){single++; music11=word(EEPROM.read(86),EEPROM.read(87));        //считываем текущее состояние режима
    tft.drawNumber(music11,295,170,1); tft.drawCentreString("D#",195,170,1);} break;        //выводим полученное значение "music11"
    case 59: if (single==0){single++; music12=word(EEPROM.read(88),EEPROM.read(89));        //считываем текущее состояние режима
    tft.drawNumber(music12,295,170,1); tft.drawCentreString("D#",195,170,1);} break;        //выводим полученное значение "music12"
    case 60: if (single==0){single++; music13=word(EEPROM.read(90),EEPROM.read(91));        //считываем текущее состояние режима
    tft.drawNumber(music13,295,170,1); tft.drawCentreString("E",195,170,1);} break;         //выводим полученное значение "music13"
    case 61: if (single==0){single++; music14=word(EEPROM.read(92),EEPROM.read(93));        //считываем текущее состояние режима
    tft.drawNumber(music14,295,170,1); tft.drawCentreString("E",195,170,1);} break;         //выводим полученное значение "music14"
    case 62: if (single==0){single++; music15=word(EEPROM.read(94),EEPROM.read(95));        //считываем текущее состояние режима
    tft.drawNumber(music15,295,170,1); tft.drawCentreString("E",195,170,1);} break;         //выводим полученное значение "music15"
    case 63: if (single==0){single++; music16=word(EEPROM.read(96),EEPROM.read(97));        //считываем текущее состояние режима
    tft.drawNumber(music16,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music16"
    case 64: if (single==0){single++; music17=word(EEPROM.read(98),EEPROM.read(99));        //считываем текущее состояние режима
    tft.drawNumber(music17,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music17"
    case 65: if (single==0){single++; music18=word(EEPROM.read(100),EEPROM.read(101));      //считываем текущее состояние режима
    tft.drawNumber(music18,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music18"
    case 66: if (single==0){single++; music19=word(EEPROM.read(102),EEPROM.read(103));      //считываем текущее состояние режима
    tft.drawNumber(music19,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music19"
    case 67: if (single==0){single++; music20=word(EEPROM.read(104),EEPROM.read(105));      //считываем текущее состояние режима
    tft.drawNumber(music20,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music20"
    case 68: if (single==0){single++; music21=word(EEPROM.read(106),EEPROM.read(107));      //считываем текущее состояние режима
    tft.drawNumber(music21,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music21"
    case 69: if (single==0){single++; music22=word(EEPROM.read(108),EEPROM.read(109));      //считываем текущее состояние режима
    tft.drawNumber(music22,295,170,1); tft.drawCentreString("C",195,170,1);} break;         //выводим полученное значение "music22"
    case 70: if (single==0){single++; music23=word(EEPROM.read(110),EEPROM.read(111));      //считываем текущее состояние режима
    tft.drawNumber(music23,295,170,1); tft.drawCentreString("C",195,170,1);} break;         //выводим полученное значение "music23"
    case 71: if (single==0){single++; music24=word(EEPROM.read(112),EEPROM.read(113));      //считываем текущее состояние режима
    tft.drawNumber(music24,295,170,1); tft.drawCentreString("C",195,170,1);} break;         //выводим полученное значение "music24"
    case 72: if (single==0){single++; music25=word(EEPROM.read(114),EEPROM.read(115));      //считываем текущее состояние режима
    tft.drawNumber(music25,295,170,1); tft.drawCentreString("-",195,170,1);} break;         //выводим полученное значение "music25"
    case 73: if (single==0){single++; music26=word(EEPROM.read(116),EEPROM.read(117));      //считываем текущее состояние режима
    tft.drawNumber(music26,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music26"
    case 74: if (single==0){single++; music27=word(EEPROM.read(118),EEPROM.read(119));      //считываем текущее состояние режима
    tft.drawNumber(music27,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music27"
    case 75: if (single==0){single++; music28=word(EEPROM.read(120),EEPROM.read(121));      //считываем текущее состояние режима
    tft.drawNumber(music28,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music28"
    case 76: if (single==0){single++; music29=word(EEPROM.read(122),EEPROM.read(123));      //считываем текущее состояние режима
    tft.drawNumber(music29,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music29"
    case 77: if (single==0){single++; music30=word(EEPROM.read(124),EEPROM.read(125));      //считываем текущее состояние режима
    tft.drawNumber(music30,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music30"
    case 78: if (single==0){single++; music31=word(EEPROM.read(126),EEPROM.read(127));      //считываем текущее состояние режима
    tft.drawNumber(music31,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music31"
    case 79: if (single==0){single++; music32=word(EEPROM.read(128),EEPROM.read(129));      //считываем текущее состояние режима
    tft.drawNumber(music32,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music32"
    case 80: if (single==0){single++; music33=word(EEPROM.read(130),EEPROM.read(131));      //считываем текущее состояние режима
    tft.drawNumber(music33,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music33"
    case 81: if (single==0){single++; music34=word(EEPROM.read(132),EEPROM.read(133));      //считываем текущее состояние режима
    tft.drawNumber(music34,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music34"
    case 82: if (single==0){single++; music35=word(EEPROM.read(134),EEPROM.read(135));      //считываем текущее состояние режима
    tft.drawNumber(music35,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music35"
    case 83: if (single==0){single++; music36=word(EEPROM.read(136),EEPROM.read(137));      //считываем текущее состояние режима
    tft.drawNumber(music36,295,170,1); tft.drawCentreString("-",195,170,1);} break;         //выводим полученное значение "music36"
    case 84: if (single==0){single++; music37=word(EEPROM.read(138),EEPROM.read(139));      //считываем текущее состояние режима
    tft.drawNumber(music37,295,170,1); tft.drawCentreString("G#",195,170,1);} break;        //выводим полученное значение "music37"
    case 85: if (single==0){single++; music38=word(EEPROM.read(140),EEPROM.read(141));      //считываем текущее состояние режима
    tft.drawNumber(music38,295,170,1); tft.drawCentreString("G#",195,170,1);} break;        //выводим полученное значение "music38"
    case 86: if (single==0){single++; music39=word(EEPROM.read(142),EEPROM.read(143));      //считываем текущее состояние режима
    tft.drawNumber(music39,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music39"
    case 87: if (single==0){single++; music40=word(EEPROM.read(144),EEPROM.read(145));      //считываем текущее состояние режима
    tft.drawNumber(music40,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music40"
    case 88: if (single==0){single++; music41=word(EEPROM.read(146),EEPROM.read(147));      //считываем текущее состояние режима
    tft.drawNumber(music41,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music41"
    case 89: if (single==0){single++; music42=word(EEPROM.read(148),EEPROM.read(149));      //считываем текущее состояние режима
    tft.drawNumber(music42,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music42"
    case 90: if (single==0){single++; music43=word(EEPROM.read(150),EEPROM.read(151));      //считываем текущее состояние режима
    tft.drawNumber(music43,295,170,1); tft.drawCentreString("B",195,170,1);} break;         //выводим полученное значение "music43"
    case 91: if (single==0){single++; music44=word(EEPROM.read(152),EEPROM.read(153));      //считываем текущее состояние режима
    tft.drawNumber(music44,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music44"
    case 92: if (single==0){single++; music45=word(EEPROM.read(154),EEPROM.read(155));      //считываем текущее состояние режима
    tft.drawNumber(music45,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music45"
    case 93: if (single==0){single++; music46=word(EEPROM.read(156),EEPROM.read(157));      //считываем текущее состояние режима
    tft.drawNumber(music46,295,170,1); tft.drawCentreString("A",195,170,1);} break;         //выводим полученное значение "music46"
    case 94: if (single==0){single++; music47=word(EEPROM.read(158),EEPROM.read(159));      //считываем текущее состояние режима
    tft.drawNumber(music47,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music47"
    case 95: if (single==0){single++; music48=word(EEPROM.read(160),EEPROM.read(161));      //считываем текущее состояние режима
    tft.drawNumber(music48,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music48"
    case 96: if (single==0){single++; music49=word(EEPROM.read(162),EEPROM.read(163));      //считываем текущее состояние режима
    tft.drawNumber(music49,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music49"
    case 97: if (single==0){single++; music50=word(EEPROM.read(164),EEPROM.read(165));      //считываем текущее состояние режима
    tft.drawNumber(music50,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music50"
    case 98: if (single==0){single++; music51=word(EEPROM.read(166),EEPROM.read(167));      //считываем текущее состояние режима
    tft.drawNumber(music51,295,170,1); tft.drawCentreString("-",195,170,1);} break;         //выводим полученное значение "music51"
    case 99: if (single==0){single++; music52=word(EEPROM.read(168),EEPROM.read(169));      //считываем текущее состояние режима
    tft.drawNumber(music52,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music52"
    case 100:if (single==0){single++; music53=word(EEPROM.read(170),EEPROM.read(171));      //считываем текущее состояние режима
    tft.drawNumber(music53,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music53"
    case 101:if (single==0){single++; music54=word(EEPROM.read(172),EEPROM.read(173));      //считываем текущее состояние режима
    tft.drawNumber(music54,295,170,1); tft.drawCentreString("E",195,170,1);} break;         //выводим полученное значение "music54"
    case 102:if (single==0){single++; music55=word(EEPROM.read(174),EEPROM.read(175));      //считываем текущее состояние режима
    tft.drawNumber(music55,295,170,1); tft.drawCentreString("E",195,170,1);} break;         //выводим полученное значение "music55"
    case 103:if (single==0){single++; music56=word(EEPROM.read(176),EEPROM.read(177));      //считываем текущее состояние режима
    tft.drawNumber(music56,295,170,1); tft.drawCentreString("-",195,170,1);} break;         //выводим полученное значение "music56"
    case 104:if (single==0){single++; music57=word(EEPROM.read(178),EEPROM.read(179));      //считываем текущее состояние режима
    tft.drawNumber(music57,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music57"
    case 105:if (single==0){single++; music58=word(EEPROM.read(180),EEPROM.read(181));      //считываем текущее состояние режима
    tft.drawNumber(music58,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music58"
    case 106:if (single==0){single++; music59=word(EEPROM.read(182),EEPROM.read(183));      //считываем текущее состояние режима
    tft.drawNumber(music59,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music59"
    case 107:if (single==0){single++; music60=word(EEPROM.read(184),EEPROM.read(185));      //считываем текущее состояние режима
    tft.drawNumber(music60,295,170,1); tft.drawCentreString("D",195,170,1);} break;         //выводим полученное значение "music60"
    case 108:if (single==0){single++; music61=word(EEPROM.read(186),EEPROM.read(187));      //считываем текущее состояние режима
    tft.drawNumber(music61,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music61"
    case 109:if (single==0){single++; music62=word(EEPROM.read(188),EEPROM.read(189));      //считываем текущее состояние режима
    tft.drawNumber(music62,295,170,1); tft.drawCentreString("F",195,170,1);} break;         //выводим полученное значение "music62"
    case 110:if (single==0){single++; select=EEPROM.read(190);                              //считываем текущее состояние режима
    tft.drawNumber(select,295,170,1); tft.drawCentreString("select",195,170,1);} break;     //выводим полученное значение "select"
    case 111:if (single==0){single++; hhalarm=EEPROM.read(191);                             //считываем текущее состояние режима
    tft.drawNumber(hhalarm,295,170,1); tft.drawCentreString("hhalarm",195,170,1);} break;   //выводим полученное значение "hhalarm"
    case 112:if (single==0){single++; mmalarm=EEPROM.read(192);                             //считываем текущее состояние режима
    tft.drawNumber(mmalarm,295,170,1); tft.drawCentreString("mmalarm",195,170,1);} break;   //выводим полученное значение "mmalarm"
    case 113:if (single==0){single++; ssalarm=EEPROM.read(193);                             //считываем текущее состояние режима
    tft.drawNumber(ssalarm,295,170,1); tft.drawCentreString("ssalarm",195,170,1);} break;   //выводим полученное значение "ssalarm"
    case 114:if (single==0){single++; alarmonoff=EEPROM.read(194);                          //считываем текущее состояние режима
    tft.drawNumber(alarmonoff,295,170,1); tft.drawCentreString("alarmonoff",195,170,1);}    //выводим полученное значение "alarmonoff"
    break;
    case 115:if (single==0){single++; alarmonoff=EEPROM.read(195);                          //считываем текущее состояние режима
    tft.drawNumber(Clock,295,170,1); tft.drawCentreString("Clock",195,170,1);} break;}      //выводим полученное значение "Clock"
}   SetStep=1; MReadPos=0; single=0; MRPos=0; flagtemp=false;                               //"SetStep" выставляем в 1 для индикации "Setting"
    preparing_the_screen();                                                                 //выходим из предустановок и вызываем подпрограмму подготовки экрана
M2:if (selringtone==1){                                                                     //если "selringtone==1"
    tft.fillRoundRect(8,8,464,304,8,TFT_GREY40);                                            //затираем предыдущие надписи
    tft.setFreeFont(FSBI18); tft.setTextColor(bordercolor);                                 //выбираем шрифт и цвет текста
    tft.drawCentreString("-- SELECT RINGTONE --",240,25,1);                                 //выводим надпись "-- SELECT RINGTONE --"
    tft.setTextColor(TFT_DARKGREY);                                                         //выбираем цвет текста
    tft.drawCentreString("Single click to return",240,205,1);                               //выводим надпись "Single click to return"
    tft.drawCentreString("Double click the select ringtone",240,240,1);                     //выводим надпись "Double click the select ringtone"
    tft.drawCentreString("Triple click play ringtone",240,275,1);                           //выводим надпись "Triple click play ringtone"
    tft.setTextColor(TFT_SILVER);                                                           //выбираем цвет текста
  if (select==0){tft.drawCentreString("Fur Elise",240,120,1);}                              //выводим надпись "Fur Elise" 
  if (select==1){tft.drawCentreString("Polonaise Oginski",240,120,1);}                      //выводим надпись "Polonaise Oginski"
while (selringtone==1){                                                                     //находимся в цикле установки пока "selringtone==1"
    butt1.tick();                                                                           //функция должна постоянно опрашиваться
  if (butt1.isDouble()){single=0; select=EEPROM.read(190);                                  //двойным кликом переключаем по кольцу
    tft.setTextColor(TFT_RED);                                                              //выбираем цвет текста
  if (select==0){if (single==0){single++; tft.fillRect(110,120,260,31,TFT_GREY40);          //если была выбрана мелодия "elis" то переключаемся на "polones"
    tft.drawCentreString("Polonaise Oginski",240,120,1); select=1;                          //выводим надпись "Polonaise Oginski"
    EEPROM.update(190,select); polones();}}                                                 //записываем в память новое значение "select" и проигрываем мелодию
  if (select==1){if (single==0){single++; tft.fillRect(110,120,260,31,TFT_GREY40);          //если была выбрана мелодия "polones" то переключаемся на "elis"
    tft.drawCentreString("Fur Elise",240,120,1); select=0;                                  //выводим надпись "Fur Elise"
    EEPROM.update(190,select); elis();}}}                                                   //записываем в память новое значение "select" и проигрываем мелодию
  if (butt1.isSingle()){beep(); selringtone=0;}                                             //одним кликом выходим из режима выбора мелодии
  if (butt1.isTriple()){                                                                    //тройным кликом 
  if (select==0){elis();}                                                                   //если "select==0" прослушиваем рингтон "К Элизе"
  if (select==1){polones();}}                                                               //если "select==1" прослушиваем рингтон "Полонез Огинского"
}   MRPos=0; single=0; goto M1;}}                                                           //сбрасываем необходимые переменные в ноль и переходим по метке М1
void elis(){                                                                                //подпрограмма рингтона "К Элизе"
  for(int i=0; i<31; i++){                                                                  //включаем цикл перебора нот
  switch(i){                                                                                //функция проигрывания рингтона
    case 0: music=659;  break;                                                              //определяем высоту тона
    case 1: music=659;  break;                                                              //----------------------
    case 2: music=659;  break;                                                              //----------------------
    case 3: music=622;  break;                                                              //----------------------
    case 4: music=622;  break;                                                              //----------------------
    case 5: music=622;  break;                                                              //----------------------
    case 6: music=659;  break;                                                              //----------------------
    case 7: music=659;  break;                                                              //----------------------
    case 8: music=659;  break;                                                              //----------------------
    case 9: music=622;  break;                                                              //----------------------
    case 10: music=622; break;                                                              //----------------------
    case 11: music=622; break;                                                              //----------------------
    case 12: music=659; break;                                                              //----------------------
    case 13: music=659; break;                                                              //----------------------
    case 14: music=659; break;                                                              //----------------------
    case 15: music=494; break;                                                              //----------------------
    case 16: music=494; break;                                                              //----------------------
    case 17: music=494; break;                                                              //----------------------
    case 18: music=587; break;                                                              //----------------------
    case 19: music=587; break;                                                              //----------------------
    case 20: music=587; break;                                                              //----------------------
    case 21: music=523; break;                                                              //----------------------
    case 22: music=523; break;                                                              //----------------------
    case 23: music=523; break;                                                              //----------------------
    case 24: music=0;   break;                                                              //----------------------
    case 25: music=440; break;                                                              //----------------------
    case 26: music=440; break;                                                              //----------------------
    case 27: music=440; break;                                                              //----------------------
    case 28: music=440; break;                                                              //----------------------
    case 29: music=440; break;                                                              //----------------------
    case 30: music=440; break;}                                                             //----------------------
    tone4.tone(music); delay(80); tone4.noTone();}}                                         //включаем выбранный тон на время 80мс и выключаем его
void polones(){                                                                             //подпрограмма рингтона "Полонез Огинского"
  for(int i=0; i<31; i++){                                                                  //включаем цикл перебора нот
  switch(i){                                                                                //функция проигрывания рингтона
    case 0: music=440;  break;                                                              //определяем высоту тона
    case 1: music=440;  break;                                                              //----------------------
    case 2: music=440;  break;                                                              //----------------------
    case 3: music=440;  break;                                                              //----------------------
    case 4: music=0;    break;                                                              //----------------------
    case 5: music=415;  break;                                                              //----------------------
    case 6: music=415;  break;                                                              //----------------------
    case 7: music=440;  break;                                                              //----------------------
    case 8: music=440;  break;                                                              //----------------------
    case 9: music=463;  break;                                                              //----------------------
    case 10: music=463; break;                                                              //----------------------
    case 11: music=463; break;                                                              //----------------------
    case 12: music=440; break;                                                              //----------------------
    case 13: music=440; break;                                                              //----------------------
    case 14: music=440; break;                                                              //----------------------
    case 15: music=349; break;                                                              //----------------------
    case 16: music=349; break;                                                              //----------------------
    case 17: music=349; break;                                                              //----------------------
    case 18: music=349; break;                                                              //----------------------
    case 19: music=0;   break;                                                              //----------------------
    case 20: music=349; break;                                                              //----------------------
    case 21: music=349; break;                                                              //----------------------
    case 22: music=330; break;                                                              //----------------------
    case 23: music=330; break;                                                              //----------------------
    case 24: music=0;   break;                                                              //----------------------
    case 25: music=294; break;                                                              //----------------------
    case 26: music=294; break;                                                              //----------------------
    case 27: music=294; break;                                                              //----------------------
    case 28: music=294; break;                                                              //----------------------
    case 29: music=349; break;                                                              //----------------------
    case 30: music=349; break;}                                                             //----------------------
    tone4.tone(music); delay(80); tone4.noTone();}                                          //включаем выбранный тон на время 80мс и выключаем его
}//************************************************************* Конец!!! ***************************************************************************
